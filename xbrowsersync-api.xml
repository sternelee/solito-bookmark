This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  FUNDING.yml
config/
  settings.default.json
src/
  common/
    enums.ts
    utils.spec.ts
    utils.ts
  docs/
    images/
      clouds.svg
      logo.svg
    index.html
    index.ts
    mixins.scss
    styles.scss
    variables.scss
  models/
    bookmarks.model.spec.ts
    bookmarks.model.ts
    newSyncLogs.model.spec.ts
    newSyncLogs.model.ts
  routers/
    api.router.spec.ts
    api.router.ts
    bookmarks.router.spec.ts
    bookmarks.router.ts
    docs.router.spec.ts
    docs.router.ts
    info.router.spec.ts
    info.router.ts
  services/
    api.service.spec.ts
    api.service.ts
    bookmarks.service.spec.ts
    bookmarks.service.ts
    info.service.spec.ts
    info.service.ts
    newSyncLogs.service.spec.ts
    newSyncLogs.service.ts
  api.ts
  config.spec.ts
  config.ts
  db.spec.ts
  db.ts
  exception.spec.ts
  exception.ts
  location.spec.ts
  location.ts
  server.spec.ts
  server.ts
  uuid.spec.ts
  uuid.ts
test/
  e2e/
    bookmarks.spec.ts
    docs.spec.ts
    info.spec.ts
    server.spec.ts
.eslintrc.json
.gitignore
.npmrc
.prettierrc.json
.stylelintrc.json
.travis.yml
jest.config.js
jestconfig.e2e.json
jestconfig.unit.json
LICENSE.md
package.json
README.md
tsconfig.eslint.json
tsconfig.json
webpack.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/FUNDING.yml">
patreon: xbrowsersync
liberapay: xbrowsersync
custom: https://link.xbrowsersync.org/cryptos
</file>

<file path="config/settings.default.json">
{
  "allowedOrigins": [],
  "dailyNewSyncsLimit": 3,
  "db": {
    "authSource": "admin",
    "connTimeout": 30000,
    "host": "127.0.0.1",
    "name": "xbrowsersync",
    "password": "",
    "port": 27017,
    "ssl": false,
    "useSRV": false,
    "username": ""
  },
  "location": "",
  "log": {
    "file": {
      "enabled": true,
      "level": "info",
      "path": "/var/log/xBrowserSync/api.log",
      "rotatedFilesToKeep": 5,
      "rotationPeriod": "1d"
    },
    "stdout": {
      "enabled": true,
      "level": "info"
    }
  },
  "maxSyncs": 5242,
  "maxSyncSize": 512000,
  "server": {
    "behindProxy": false,
    "host": "127.0.0.1",
    "https": {
      "certPath": "",
      "enabled": false,
      "keyPath": ""
    },
    "port": 8080,
    "relativePath": "/"
  },
  "status": {
    "allowNewSyncs": true,
    "message": "",
    "online": true
  },
  "tests": {
    "db": "xbrowsersynctest",
    "port": 8081
  },
  "throttle": {
    "maxRequests": 1000,
    "timeWindow": 300000
  }
}
</file>

<file path="src/common/enums.ts">
export enum LogLevel {
  Error,
  Info,
}

export enum ServiceStatus {
  online = 1,
  offline = 2,
  noNewSyncs = 3,
}

export enum Verb {
  delete = 'delete',
  get = 'get',
  options = 'options',
  patch = 'patch',
  post = 'post',
  put = 'put',
}
</file>

<file path="src/common/utils.spec.ts">
import 'jest';
import * as Config from '../config';
import { ServiceNotAvailableException } from '../exception';
import { checkServiceAvailability } from './utils';

describe('Server', () => {
  let testConfig: Config.IConfigSettings;

  beforeEach(() => {
    testConfig = Config.get(true);
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('checkServiceAvailability: should not throw an error when status set as online in config settings', () => {
    testConfig.status.online = true;
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    expect(() => {
      checkServiceAvailability();
    }).not.toThrowError();
  });

  it('checkServiceAvailability: should throw a ServiceNotAvailableException when status set as offline in config settings', () => {
    testConfig.status.online = false;
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    expect(() => {
      checkServiceAvailability();
    }).toThrow(ServiceNotAvailableException);
  });
});
</file>

<file path="src/common/utils.ts">
import * as Config from '../config';
import { ServiceNotAvailableException } from '../exception';

// Throws an error if the service status is set to offline in config
export const checkServiceAvailability = (): void => {
  if (!Config.get().status.online) {
    throw new ServiceNotAvailableException();
  }
};
</file>

<file path="src/docs/images/clouds.svg">
<svg version="1.1" viewBox="0 0 1668 1000" xmlns="http://www.w3.org/2000/svg"><polygon points="782.56 330.6 782.56 330.66 802.56 319.13 802.5 319.1" fill="none"/><polygon points="872.6 313.29 872.6 313.35 882.59 307.59 882.54 307.56" fill="none"/><polygon points="2.074 502.97 0 501.78 0 501.82 2.074 503.01" fill="none"/><polygon points="852.59 313.29 852.59 313.35 862.58 307.59 862.53 307.56" fill="none"/><polygon points="812.58 324.83 812.58 324.89 842.57 307.59 842.52 307.56" fill="none"/><polygon points="1339.7 751.1 1349.7 745.33 1339.7 751.08" fill="none"/><polygon points="1349.6 733.81 1349.6 733.81 1349.6 745.27 1349.7 745.33 1349.7 733.79 1359.7 728.01 1359.7 728" fill="none"/><polygon points="1449.8 664.58 1459.7 670.31 1449.8 676.05 1449.8 676.07 1459.8 670.3 1449.8 664.53" fill="none"/><polygon points="612.42 474.94 612.42 486.48 602.42 492.25 602.42 515.34 602.47 515.37 602.48 515.36 602.48 492.27 612.49 486.5 612.49 474.96 622.48 469.2 622.42 469.16" fill="none"/><polygon points="22.083 514.46 22.167 514.42 22.083 514.37" fill="none"/><polygon points="122.13 502.92 122.2 502.88 122.13 502.83" fill="none"/><polygon points="834.31 654.94 834.31 654.94 844.26 649.2 844.23 649.19" fill="none"/><polygon points="142.13 491.38 142.16 491.36 142.13 491.35" fill="none"/><polygon points="752.48 347.96 752.48 359.5 742.48 365.27 742.48 376.82 722.47 388.36 722.47 399.9 702.46 411.45 702.46 422.99 682.45 434.53 682.45 446.08 652.44 463.39 652.44 474.94 642.5 480.67 642.5 480.73 652.51 474.96 652.51 463.41 682.52 446.1 682.52 434.56 702.53 423.01 702.53 411.47 722.54 399.92 722.54 388.38 742.54 376.84 742.54 365.3 752.55 359.52 752.55 347.98 762.55 342.21 762.6 330.64 772.54 324.9 772.49 324.87 762.48 330.64 762.48 342.19 732.47 324.87 762.48 342.19" fill="none"/><polygon points="502.37 573.05 492.37 578.82 492.37 578.83 502.38 573.05 502.38 561.52 502.37 561.51" fill="none"/><polygon points="522.38 538.42 522.38 549.97 512.38 555.74 512.38 555.74 522.39 549.97 522.39 538.42 532.39 532.66 532.38 532.65" fill="none"/><polygon points="824.3 683.78 820.26 686.13 824.31 683.8 824.31 672.26 827.54 670.39 824.3 672.24" fill="none"/><polygon points="804.29 706.89 804.3 706.89 804.3 695.43 804.29 695.44" fill="none"/><polygon points="162.14 491.38 162.2 491.34 162.14 491.31" fill="none"/><polygon points="834.31 666.48 804.29 649.22 834.26 666.51" fill="none"/><polygon points="1369.7 733.79 1369.7 733.78 1369.7 733.78" fill="none"/><polygon points="892.66 313.26 892.66 313.32 902.6 307.59 902.54 307.56" fill="none"/><polygon points="679.71 70.764 679.7 70.768 679.7 82.209 679.71 82.205" fill="none"/><polygon points="1171.4 257.99 1141.4 240.68" fill="none"/><polygon points="144.85 824.5 144.85 824.5 154.86 830.28 154.87 830.27 144.33 824.21" fill="none"/><polygon points="1351.5 177.19 1351.5 177.19 1351.5 177.18" fill="none"/><polygon points="452.59 146.99 452.59 146.99" fill="none"/><polygon points="1659.9 531.74 1659.9 531.71 1659.9 531.78" fill="none"/><polygon points="1519.8 601.03 1519.8 601.04 1519.8 589.52 1519.8 589.54" fill="none"/><polygon points="1619.8 577.95 1620 577.88 1619.8 577.81" fill="none"/><polygon points="679.59 82.249 659.7 93.748 679.61 82.26" fill="none"/><rect x="1381.5" y="171.42" width="0" height="0" fill="none"/><polygon points="709.72 41.865 709.71 41.87 709.71 53.351 709.72 53.347" fill="none"/><polygon points="144.85 847.59 144.87 847.58 134.36 841.54" fill="none"/><polygon points="1609.8 572.17 1609.8 583.6 1609.8 583.63 1609.8 572.18 1599.4 566.18" fill="none"/><polygon points="719.72 59.118 719.64 59.169 719.72 59.22" fill="none"/><path d="m1639.9 635.67v0.014l-0.012-7e-3 -0.04 0.023v-0.046l-9.964-5.749-50.062 28.881v-0.036l-9.973-5.754-0.031 0.018v11.543l-50.022 28.858v-11.543l-0.033 0.019-0.014 11.496-9.956-5.744-40.018 23.087v11.543l-10.004 5.772v11.543l-30.013 17.315v-11.543l-0.053 0.031 0.029 0.017-0.014 11.503-9.991-5.764-39.992 23.072v11.543l-30.013 17.315v-11.543l-0.08 0.046-0.014 11.424-9.893-5.708-20.026 11.553v11.543l-60.011 34.604-29.94-17.273-0.059-11.545 20.009-11.543 29.971 17.291 0.028-0.016v-11.506l-0.014 11.503-29.94-17.273-0.059-11.545 30.013 17.315v-0.036l-30.013-17.315 20.009-11.543 0.073 0.042-0.059-11.493-0.109-0.063 20.009-11.543 30.013 17.315-19.976 11.525 0.062 0.036v-0.046l19.996-11.536-0.023-0.013v-9e-3l-29.857-17.225-0.059-11.545 29.952 17.28v-0.038l6e-3 -4e-3 -29.958-17.284 20.009-11.543 29.952 17.28v-0.037l-29.893-17.246-0.058-11.455-0.15-0.087 10.057-5.777-0.059-11.541v-3e-3l3e-3 2e-3 20.006-11.542 10.065 5.807 20.042-11.601v-11.474l-0.094-0.055 20.009-11.543 30.013 17.315-19.948 11.509 0.034 0.02 20.009-11.543v-0.025l-29.952-17.28v-11.543l3e-3 2e-3 29.949-17.327 10.015 5.778v-11.541l0.049 0.028 19.96-11.515 29.952 17.28 0.016-9e-3 -29.978-17.295v-11.543l30.013 17.315v-0.04l0.04-0.023-30.04-17.279 10.027-5.785 29.977 17.286v-0.044l-29.853-17.222v-11.549l0.017 0.01 29.828-17.341-0.015-9e-3v-11.544l0.039 0.022 29.997-17.333 10.119 5.838 0.045-0.026 9.901 5.712 9.901-5.712 9.978 5.756 0.049-0.028 10.096 5.825 9.997-5.768-0.107-0.062v-11.543l0.03 0.017 9.997-5.768 10.032 5.785 0.077-0.045v-11.433l29.931 17.268v-0.045l6e-3 -4e-3 -29.937-17.271 20.009-11.543 29.931 17.268v-0.017l-29.996-17.305-0.017-23.073 0.12 0.069 9.924-5.725 9.894 5.705 0.118-0.068 0.03 0.017-0.017-22.959 28.088 16.21v-0.04l-28.092-16.207 20.009-11.543 8.084 4.664v-478.81h-805.79l-22.438 12.945-10.004-5.772-10.004 5.772-10.004-5.772v11.543l-30.013 17.315-30.013-17.315v-11.543l10.004-5.772v-1.401h-759.74v478.69l12.063 6.959 30.029-17.358 20.133 11.615 9.979-5.757 9.955 5.743 9.955-5.743 9.876 5.698 0.07-0.04v-11.532l30.013 17.315v11.455l0.058 0.033-0.015-11.447 0.057-0.033-10.722-6.186-19.391-11.154 10.027-5.785 10.073 5.809 10.009-5.774 10.02 5.781 19.955-11.542 30.013 17.315v11.543l-70.045 40.427v11.543l-90.039 51.945v11.543l-32.073 18.506v380.43h759.74v-10.27l20.009-11.543v-11.543l20.009-11.543v-11.543l10.004-5.772 30.013 17.315v-11.543l20.009-11.543v-11.545l20.009-11.543v-11.543l10.004-5.772v-11.543l10.004-5.772v-11.543l20.009-11.543v-11.543l30.013-17.315v-11.543l10.004-5.772 30.013 17.315 10.004 5.772 10.004-5.772 10.004 5.772 10.004-5.772 10.004 5.772 20.009-11.543 10.004 5.772 10.004-5.772 30.013 17.315v11.543l-50.022 28.858-10.004-5.772-20.009 11.543v11.543l-50.021 28.858-10.004-5.772-20.009 11.543v11.543l-30.012 17.316v11.543l-57.818 33.357h806.01v-380.55l-28.115 16.22zm-1010.2-559.23l20-11.559 2e-3 1e-3v-11.422l30.02-17.422v-11.543l10.004-5.772 10.014 5.778 9.994-5.778 30.013 17.315v6e-3l9.999 5.769 5e-3 -3e-3v11.543l-30.013 17.315v0.102l-10.003-5.873-10.004 5.772v11.543l-40.017 23.087-30.013-17.315v-11.544zm-314.76 696.13l-10.004 5.772v11.543l-30.013 17.315-10.004-5.772-10.004 5.772v11.543l-30.013 17.315-10.004-5.772-40.017 23.087-10.004-5.772-20.009 11.543-30.013-17.315v-11.51l-0.116-0.067 10.027-5.785 30.107 17.361-30.013-17.315v-11.51l-0.116-0.067 10.027-5.785 30.107 17.361-30.013-17.315v-11.492l-0.206-0.118 20.12-11.523 30.107 17.361-30.013-17.315v-11.492l-0.206-0.118 30.125-17.295 30.107 17.361-30.013-17.315v-11.518l-0.022-0.013 0.022-0.013 10.004-5.772 19.867 11.461 30.061-17.279 29.983 17.29 10.034-5.746 10.094 5.82 5e-3 -3e-3v5e-3l20.009 11.538v11.549zm127.66-596.71l-20.009 11.543v11.543l-40.017 23.087-10.004-5.772-90.039 51.945-10.004-5.772-40.017 23.087-10.004-5.772-30.013 17.315-10.004-5.772-80.035 46.174-30.013-17.315v-11.543l20.009-11.543v-11.543l20.009-11.543 10.004 5.772 10.004-5.772v-11.543l10.004-5.772v-11.543l10.004-5.772v-11.543l20.009-11.543v-11.543l20.009-11.543 30.013 17.315v11.543l10.004 5.772v-23.087l10.004-5.772v-23.087l20.009-11.543v-11.543l10.004-5.772v-11.543l10.004-5.772v-11.543l20.009-11.543 30.013 17.315v11.543l10.004 5.772 10.004-5.772 10.004 5.772 20.009-11.543 10.004 5.772 30.013-17.315 10.004 5.772 30.013-17.315 30.013 17.315 10.004 5.772v11.543l-50.022 28.858-10.004-5.772v11.541zm199.84 339.55v11.481l-9.95-5.74-19.993 11.534v-11.543l-0.07 0.04v11.481l-9.95-5.74-9.989 5.763v-11.526l-0.07-0.04v11.543l-19.996-11.536v11.536l-10.004 5.772v11.543l-10.004 5.772v11.543l-20.009 11.543v-11.543l-0.013 7e-3v11.536l-9.991-5.764v11.536l-20.009 11.543v-11.543l-0.013 7e-3v11.536l-9.998-5.768-9.998 5.768v-11.536l-0.013-7e-3v11.543l-30.013-17.315v-11.543l20.009-11.543v-11.543l20.009-11.543v-11.543l20.009-11.543 10.004 5.772 20.009-11.543 30.013 17.315-30 17.308v8e-3l30.006-17.311-10.011-5.775v-11.543l10.004-5.772v-23.087l10.004-5.772v-11.548l20.009-11.543 20.009 11.543v-11.543l30.013-17.315v-11.543l20.009-11.543v-11.543l20.009-11.543v-11.543l20.009-11.543v-11.543l10.004-5.772v-11.543l10.004-5.772v-11.543l20.009-11.543 10.004 5.772 20.009-11.543 10.004 5.772 30.013-17.315 10.004 5.772 10.004-5.772 10.004 5.772 10.004-5.772 10.004 5.772 10.004-5.772 30.013 17.315 0.054 0.031 0.015-9e-3v0.018l9.934 5.731-9.879 5.7v0.063l9.949-5.74v11.543l-30.013 17.315v11.543l-10.004 5.772v11.543l-10.004 5.772 0.683 11.149-10.687 6.166v11.543l-30.013 17.315v11.543l-60.026 34.63v-11.543l-0.07 0.04v11.481l-9.95-5.74-29.997 17.306v-11.543l-0.07 0.04v11.481l-9.95-5.74-9.989 5.763v11.543l-70.03 40.402v-11.543l-0.068 0.036zm301.93 133.77l-30.013 17.315v11.543l-30.013 17.315v-0.044l-9.966-5.749-20.047 11.566v11.543l-50.022 28.858v-11.543l-0.092 0.053 0.082 0.047v11.543l-10.086-5.819-39.925 23.034v-11.543l-0.09 0.052 0.09 0.052v11.543l-10.094-5.823-19.919 11.492v0.102l-30.013-17.315v-11.592l-0.183-0.106 30.196-17.162v-11.543l30.013 17.315v11.442-11.543l0.013-8e-3 -30.118-17.324 30.196-17.162 9.9 5.711 10.007-5.703 29.892 17.245 0.045-0.026-29.937-17.271v-11.543l20.006-11.652v-11.543l10.007-5.704-4e-3 -11.592 20.019-11.595 10.061 5.804 9.936-5.756 10.034 5.789v-11.569l9.988-5.76 10.005 5.771h1e-3l10.071 5.809 10.072-5.733 9.937 5.733 10.072-5.733 29.878 17.237v11.542zm477.13-512.38l20.009-11.543v-11.543l30.013-17.315v-11.544l20.009-11.543 30.013 17.315 10.004-5.772 30.013 17.315v11.543l-50.022 28.858-10.004-5.772-10.004 5.772v11.543l-10.004 5.772-10.004-5.772-20.009 11.543-30.013-17.315v-11.542zm-210.09 167.38l-30.013 17.315-10.004-5.772-30.013 17.315-30.013-17.315v-11.543l10.004-5.772v-11.543l10.004-5.772v-11.543l20.009-11.543-10.004-5.772v-11.543l10.004-5.772v-23.087l10.004-5.772v-11.543l20.009-11.543v-11.543l20.009-11.543v-11.543l20.009-11.543 10.004 5.772 10.004-5.772 10.004 5.772 10.004-5.772 10.004 5.772 20.009-11.543 30.013 17.315 10.004 5.772 20.009-11.543 20.009 11.543 10.004-5.772 10.004 5.772 10.004-5.772 30.013 17.315v11.543l-10.004 5.772v11.543l-30.013 17.315v11.543l-40.017 23.087-10.004-5.772-60.026 34.63-10.004-5.772-40.017 23.087-10.004-5.772-10.004 5.772v11.542z" fill="none"/><polygon points="849.78 983.96 869.79 972.42 849.78 983.93" fill="none"/><polygon points="1579.8 589.48 1579.8 589.5 1579.9 589.45 1579.9 589.44" fill="none"/><polygon points="1589.8 595.27 1589.9 595.22 1589.8 595.17" fill="none"/><polygon points="492.61 135.44 502.61 129.67" fill="none"/><polygon points="2.074 503.01 0 501.82 0 524.76 2.074 525.95" fill="#A3A3A3"/><polygon points="132.07 497.04 132.07 485.59 102.06 468.28 102.06 479.81 102.12 479.77" fill="#A3A3A3"/><polygon points="2.074 502.92 2.159 502.87 0 501.63 0 501.78 2.074 502.97" fill="#D6D6D6"/><polygon points="0 478.69 0 492.62 12.063 485.65" fill="#D6D6D6"/><polygon points="2.074 526.01 2.074 525.95 0 524.76 0 527.2" fill="#D6D6D6"/><polygon points="122.13 491.38 122.13 502.83 122.2 502.88 132.13 497.15 132.13 497.08 132.07 497.04 102.12 479.77 102.06 479.81 101.99 479.85 122.05 491.42" fill="#D6D6D6"/><polygon points="22.083 491.38 22.083 514.37 22.167 514.42 62.074 491.39 52.194 485.69 62.224 479.91 42.091 468.29 12.063 485.65 0 492.62 0 501.63 2.159 502.87" fill="#D6D6D6"/><polygon points="82.109 491.46 82.109 502.92 92.038 497.19" fill="#D6D6D6"/><polygon points="72.104 497.15 82.033 491.42 72.104 485.69" fill="#D6D6D6"/><polygon points="52.194 485.69 62.074 491.39 72.104 485.61 72.104 485.69 82.158 479.89 72.203 474.15 62.224 479.91" fill="#D6D6D6"/><polygon points="72.104 485.69 82.033 491.42 82.109 491.38 82.109 491.46 92.038 497.19 102.12 491.38 102.12 502.92 122.05 491.42 101.99 479.85 92.113 474.15 82.158 479.89" fill="#D6D6D6"/><polygon points="121.45 479.41 132.17 485.6 132.19 485.59" fill="#D6D6D6"/><polygon points="142.12 479.88 142.13 491.35 142.16 491.36 152.2 485.57 132.23 474.05 142.19 468.29 132.17 462.51 122.16 468.28 142.19 479.84" fill="#D6D6D6"/><polygon points="152.2 485.57 162.14 479.84 162.14 491.31 162.2 491.34 192.16 474.06 162.14 456.75 142.19 468.29 132.23 474.05" fill="#D6D6D6"/><polygon points="142.12 479.86 142.12 479.88 142.19 479.84 122.16 468.28 112.09 462.48 102.06 468.26 121.45 479.41 132.19 485.59" fill="#D6D6D6"/><polygon points="32.072 589.52 122.11 537.58 122.11 526.03 192.16 485.61 192.16 474.06 162.2 491.34 162.14 491.38 162.14 491.31 162.14 479.84 152.2 485.57 142.16 491.36 142.13 491.38 142.13 491.35 142.12 479.88 142.12 479.86 132.19 485.59 132.17 485.6 132.12 485.63 132.13 497.08 132.13 497.15 122.2 502.88 122.13 502.92 122.13 502.83 122.13 491.38 122.05 491.42 102.12 502.92 102.12 491.38 92.038 497.19 82.109 502.92 82.109 491.46 82.109 491.38 82.033 491.42 72.104 497.15 72.104 485.69 72.104 485.61 62.074 491.39 22.167 514.42 22.083 514.46 22.083 514.37 22.083 491.38 2.159 502.87 2.074 502.92 2.074 502.97 2.074 503.01 2.074 525.95 2.074 526.01 0 527.2 0 619.57 32.072 601.07" fill="#fff"/><polygon points="694.25 747.39 724.26 764.7 724.26 764.6 694.25 747.29" fill="#A3A3A3"/><polygon points="754.28 758.93 754.28 747.39 754.19 747.34 744.18 753.11" fill="#A3A3A3"/><polygon points="754.28 735.74 754.28 724.3 724.26 706.99 724.26 718.53 754.19 735.8" fill="#A3A3A3"/><polygon points="804.29 741.62 804.29 730.07 804.21 730.02 794.2 735.8" fill="#A3A3A3"/><polygon points="804.29 695.44 774.28 678.12 774.28 689.66 804.21 706.94 804.29 706.89" fill="#A3A3A3"/><polygon points="824.3 672.24 794.28 654.92 794.28 666.47 824.3 683.78" fill="#A3A3A3"/><polygon points="834.31 654.94 834.31 654.94 834.3 654.94 804.28 637.63 804.29 649.22 834.31 666.48" fill="#A3A3A3"/><polygon points="874.37 689.55 884.33 695.3 884.33 683.8" fill="#A3A3A3"/><polygon points="874.26 643.43 874.27 643.43 874.33 643.4 874.33 643.47 884.27 649.2 884.33 649.17 884.33 637.7 854.33 620.3 854.33 631.87 874.31 643.4" fill="#A3A3A3"/><polygon points="724.26 753.06 694.25 735.8 694.25 735.85 694.25 747.29 724.26 764.6 724.26 753.16" fill="#A3A3A3"/><polygon points="724.26 753.06 754.19 735.8 724.26 718.53 694.07 735.69 694.25 735.8 724.26 753.06" fill="#D6D6D6"/><polygon points="754.28 701.11 764.27 695.42 754.37 689.71 724.17 706.87 754.29 724.19 774.28 712.66" fill="#D6D6D6"/><polygon points="774.28 712.66 784.29 706.89 784.29 718.43 804.17 706.96 774.28 689.72 764.27 695.42 754.28 701.11" fill="#D6D6D6"/><polygon points="804.3 695.43 804.3 695.34 820.26 686.13 824.3 683.78 794.28 666.47 774.28 678.12 804.29 695.44" fill="#D6D6D6"/><polygon points="827.54 670.39 834.26 666.51 804.29 649.22 794.28 654.92 824.3 672.24" fill="#D6D6D6"/><polygon points="854.33 631.93 874.26 643.43 874.31 643.4 854.33 631.87 844.3 626.08 834.36 631.84 844.5 637.68" fill="#D6D6D6"/><polygon points="844.23 649.19 844.26 649.2 854.32 643.4 854.32 654.94 864.32 649.17 854.28 643.37" fill="#D6D6D6"/><polygon points="834.31 654.94 844.23 649.19 854.28 643.37 844.46 637.71 844.5 637.68 834.36 631.84 824.3 626.03 804.28 637.63 834.3 654.94" fill="#D6D6D6"/><polygon points="874.33 654.94 884.27 649.2 874.33 643.47" fill="#D6D6D6"/><polygon points="854.33 631.93 844.5 637.68 844.46 637.71 854.28 643.37 864.32 649.17 874.27 643.43 874.26 643.43" fill="#D6D6D6"/><polygon points="884.33 637.66 864.34 626.07 874.33 620.31 864.32 614.54 854.33 620.3 884.33 637.7" fill="#D6D6D6"/><polygon points="894.34 643.4 894.34 643.4 894.34 643.39" fill="#D6D6D6"/><polygon points="884.33 637.66 884.33 637.62 884.34 637.62 874.34 631.85 884.4 626.12 874.33 620.31 874.33 620.31 864.34 626.07" fill="#D6D6D6"/><polygon points="914.35 643.4 904.34 637.62 904.34 649.17" fill="#D6D6D6"/><polygon points="894.34 643.4 904.34 637.62 894.34 631.85 894.34 643.39" fill="#D6D6D6"/><polygon points="874.34 631.85 884.34 637.62 894.34 631.85 904.41 626.12 894.47 620.39 884.4 626.12" fill="#D6D6D6"/><polygon points="904.41 626.12 894.34 631.85 904.34 637.62 904.34 637.62 904.34 637.62 914.35 643.4 924.35 637.62 924.35 649.17 944.36 637.62 914.48 620.39" fill="#D6D6D6"/><polygon points="924.35 637.62 914.35 643.4 904.34 649.17 904.34 637.62 904.34 637.62 904.34 637.62 894.34 643.4 894.34 643.4 894.34 643.39 894.34 631.85 884.34 637.62 884.33 637.62 884.33 637.66 884.33 637.7 884.33 649.17 884.27 649.2 874.33 654.94 874.33 643.47 874.33 643.4 874.27 643.43 864.32 649.17 854.32 654.94 854.32 643.4 844.26 649.2 834.31 654.94 834.31 666.48 834.26 666.51 827.54 670.39 824.31 672.26 824.31 683.8 820.26 686.13 804.3 695.34 804.3 695.43 804.3 706.89 804.29 706.89 804.21 706.94 804.17 706.96 784.29 718.43 784.29 706.89 774.28 712.66 754.29 724.19 754.28 724.2 754.28 735.74 754.28 735.74 754.19 735.8 724.26 753.06 724.26 753.06 724.26 753.16 724.26 764.6 744.18 753.11 754.19 747.34 754.28 747.29 754.28 758.83 794.2 735.8 804.21 730.02 804.3 729.97 804.3 741.52 854.32 712.66 854.32 701.11 874.37 689.55 884.33 683.8 884.33 695.3 884.33 695.34 914.35 678.03 914.35 666.48 944.36 649.17 944.36 637.62 924.35 649.17" fill="#fff"/><polygon points="779.75 978.19 759.74 989.73 777.54 1e3 801.97 1e3 809.76 995.5" fill="#D6D6D6"/><polygon points="829.77 972.42 822.47 968.2 799.76 955.1 779.75 966.64 809.76 983.96" fill="#D6D6D6"/><polygon points="839.78 955.1 809.76 937.78 799.76 943.56 829.76 960.86" fill="#D6D6D6"/><polygon points="829.77 972.42 829.77 972.42 822.47 968.2" fill="#D6D6D6"/><polygon points="829.77 960.87 839.78 955.1 829.76 960.86" fill="#D6D6D6"/><polygon points="839.78 978.19 849.78 972.42 849.78 983.93 869.79 972.42 839.78 955.1" fill="#D6D6D6"/><polygon points="889.8 949.33 859.78 932.01 839.78 943.56 869.79 960.87" fill="#D6D6D6"/><polygon points="909.81 926.24 879.79 908.93 859.78 920.47 889.8 937.78" fill="#D6D6D6"/><polygon points="919.81 908.93 889.8 891.61 879.79 897.38 909.81 914.7" fill="#D6D6D6"/><polygon points="929.81 891.61 899.8 874.3 889.8 880.07 919.81 897.38" fill="#D6D6D6"/><polygon points="949.82 868.52 919.81 851.21 899.8 862.75 929.81 880.07" fill="#D6D6D6"/><polygon points="979.84 839.67 949.82 822.35 919.81 839.67 949.82 856.98" fill="#D6D6D6"/><polygon points="1009.8 845.44 1009.8 845.44" fill="#D6D6D6"/><polygon points="989.84 822.35 959.83 805.04 949.82 810.81 979.84 828.12" fill="#D6D6D6"/><polygon points="999.84 828.12 989.84 822.35 989.84 833.89" fill="#D6D6D6"/><polygon points="1019.9 851.21 1029.9 845.44 1019.9 839.67" fill="#D6D6D6"/><polygon points="999.84 828.12 999.84 839.67 1009.8 833.89 1019.9 828.12 1009.8 822.35 999.84 828.12 989.84 833.89" fill="#D6D6D6"/><polygon points="1009.8 845.44 1009.8 845.44 1019.9 839.67 1009.8 833.89" fill="#D6D6D6"/><polygon points="1039.9 851.21 1049.9 845.44 1039.9 839.67" fill="#D6D6D6"/><polygon points="1009.8 833.89 1019.9 839.67 1019.9 839.67 1019.9 839.67 1029.9 845.44 1039.9 839.67 1029.9 833.89 1039.9 828.12 1029.9 822.35 1019.9 828.12" fill="#D6D6D6"/><polygon points="1029.9 833.89 1039.9 839.67 1039.9 839.67 1039.9 839.67 1049.9 845.44 1059.9 839.67 1059.9 851.21 1079.9 839.67 1059.9 828.12 1069.9 822.35 1059.9 816.58 1039.9 828.12" fill="#D6D6D6"/><polygon points="1079.9 839.67 1089.9 833.89 1089.9 845.44 1109.9 833.89 1079.9 816.58 1069.9 822.35 1059.9 828.12" fill="#D6D6D6"/><polygon points="759.74 1e3 777.54 1e3 759.74 989.73" fill="#A3A3A3"/><polygon points="809.76 983.96 779.75 966.64 779.75 978.19 809.76 995.5" fill="#A3A3A3"/><polygon points="829.77 972.42 829.77 960.87 829.76 960.86 799.76 943.56 799.76 955.1 822.47 968.2" fill="#A3A3A3"/><polygon points="869.79 960.87 839.78 943.56 839.78 955.1 869.79 972.42" fill="#A3A3A3"/><polygon points="889.8 937.78 859.78 920.47 859.78 932.01 889.8 949.33" fill="#A3A3A3"/><polygon points="909.81 914.7 879.79 897.38 879.79 908.93 909.81 926.24" fill="#A3A3A3"/><polygon points="919.81 897.38 889.8 880.07 889.8 891.61 919.81 908.93" fill="#A3A3A3"/><polygon points="929.81 880.07 899.8 862.75 899.8 874.3 929.81 891.61" fill="#A3A3A3"/><polygon points="949.82 856.98 919.81 839.67 919.81 851.21 949.82 868.52" fill="#A3A3A3"/><polygon points="979.84 828.12 949.82 810.81 949.82 822.35 979.84 839.67" fill="#A3A3A3"/><polygon points="1049.9 868.52 1059.9 874.3 1059.9 862.75" fill="#A3A3A3"/><polygon points="969.83 914.7 979.84 920.47 979.84 908.93" fill="#A3A3A3"/><polygon points="919.81 955.1 949.82 937.78 949.82 926.24 969.83 914.7 979.84 908.93 979.84 920.47 1029.9 891.61 1029.9 880.07 1049.9 868.52 1059.9 862.75 1059.9 874.3 1109.9 845.44 1109.9 833.89 1089.9 845.44 1089.9 833.89 1079.9 839.67 1059.9 851.21 1059.9 839.67 1049.9 845.44 1039.9 851.21 1039.9 839.67 1039.9 839.67 1039.9 839.67 1029.9 845.44 1019.9 851.21 1019.9 839.67 1019.9 839.67 1019.9 839.67 1009.8 845.44 1009.8 845.44 1009.8 845.44 1009.8 833.89 999.84 839.67 999.84 828.12 989.84 833.89 989.84 822.35 979.84 828.12 979.84 839.67 949.82 856.98 949.82 868.52 929.81 880.07 929.81 891.61 919.81 897.38 919.81 908.93 909.81 914.7 909.81 926.24 889.8 937.78 889.8 949.33 869.79 960.87 869.79 972.42 849.78 983.96 849.78 983.93 849.78 972.42 839.78 978.19 839.78 955.1 829.77 960.87 829.77 972.42 829.77 972.42 809.76 983.96 809.76 995.5 801.97 1e3 861.99 1e3 919.81 966.64" fill="#fff"/><polygon points="72.429 308.6 72.429 320.14 102.44 337.45 102.44 325.91" fill="#A3A3A3"/><polygon points="122.45 302.82 92.438 285.51 92.438 297.05 122.45 314.37" fill="#A3A3A3"/><polygon points="162.47 279.74 132.46 262.42 132.46 273.96 162.47 291.28" fill="#A3A3A3"/><polygon points="162.47 268.19 172.47 273.96 172.47 262.42 142.46 245.11 142.46 256.65" fill="#A3A3A3"/><polygon points="182.48 291.28 192.48 297.05 192.48 285.51" fill="#A3A3A3"/><rect transform="matrix(-.8662 -.4997 .4997 -.8662 177.07 589.57)" x="161.7" y="271.08" width="11.55" height="0" fill="#A3A3A3"/><polygon points="222.49 279.74 232.5 285.51 232.5 273.96" fill="#A3A3A3"/><polygon points="182.48 245.11 152.46 227.79 152.46 239.33 182.48 256.65" fill="#A3A3A3"/><polygon points="172.47 204.7 172.47 204.7" fill="#A3A3A3"/><polygon points="202.48 222.02 172.47 204.7 172.47 216.25 202.48 233.56" fill="#A3A3A3"/><polygon points="272.52 262.42 282.52 268.19 282.52 256.65" fill="#A3A3A3"/><polygon points="242.5 233.56 242.5 233.56 262.51 245.11 262.51 222.02 232.5 204.7 232.5 227.79" fill="#A3A3A3"/><polygon points="232.5 204.7 232.5 204.7" fill="#A3A3A3"/><polygon points="272.52 193.16 242.5 175.85 242.5 198.93 272.52 216.25" fill="#A3A3A3"/><polygon points="292.52 170.07 262.51 152.76 262.51 164.3 292.52 181.62" fill="#A3A3A3"/><polygon points="302.53 152.76 272.52 135.44 272.52 146.99 302.53 164.3" fill="#A3A3A3"/><polygon points="312.53 135.44 282.52 118.13 282.52 129.67 312.53 146.99" fill="#A3A3A3"/><polygon points="372.56 216.25 382.56 222.02 382.56 210.48" fill="#A3A3A3"/><polygon points="452.59 158.53 442.59 164.3 452.59 170.07" fill="#A3A3A3"/><polygon points="122.45 314.37 92.438 297.05 72.429 308.6 102.44 325.91" fill="#D6D6D6"/><polygon points="132.46 297.05 112.45 285.51 122.45 279.74 112.45 273.96 92.438 285.51 122.45 302.82" fill="#D6D6D6"/><polygon points="362.55 164.3 372.56 158.53 352.55 146.99 362.55 141.22 352.55 135.44 342.54 141.22 362.55 152.76" fill="#D6D6D6"/><polygon points="372.56 158.53 382.56 152.76 382.56 164.3 402.57 152.76 382.56 141.22 392.57 135.44 382.56 129.67 362.55 141.22 352.55 146.99" fill="#D6D6D6"/><polygon points="402.57 152.76 412.58 146.99 412.58 158.53 442.59 141.22 422.58 129.67 432.58 123.9 422.58 118.13 392.57 135.44 382.56 141.22" fill="#D6D6D6"/><polygon points="502.61 129.67 492.61 123.9 492.61 135.44" fill="#D6D6D6"/><polygon points="442.59 141.22 452.59 135.44 452.59 146.99 452.59 146.99 492.61 123.9 462.6 106.59 432.58 123.9 422.58 129.67" fill="#D6D6D6"/><polygon points="132.46 297.05 142.46 291.28 142.46 302.82 162.47 291.28 132.46 273.96 122.45 279.74 112.45 285.51" fill="#D6D6D6"/><polygon points="172.47 273.96 162.47 268.19 142.46 256.65 132.46 262.42 162.47 279.74" fill="#D6D6D6"/><polygon points="182.48 256.65 152.46 239.33 142.46 245.11 172.47 262.42" fill="#D6D6D6"/><polygon points="202.48 233.56 172.47 216.25 152.46 227.79 182.48 245.11" fill="#D6D6D6"/><polygon points="222.49 210.48 192.48 193.16 172.47 204.7 172.47 204.7 202.48 222.02" fill="#D6D6D6"/><polygon points="232.5 227.79 232.5 239.33 242.5 233.56 232.5 227.79 222.49 222.02 222.49 233.56" fill="#D6D6D6"/><polygon points="242.5 256.65 262.51 245.11 242.5 233.56" fill="#D6D6D6"/><polygon points="272.52 216.25 242.5 198.93 232.5 204.7 232.5 204.7 262.51 222.02" fill="#D6D6D6"/><polygon points="292.52 181.62 262.51 164.3 242.5 175.85 272.52 193.16" fill="#D6D6D6"/><polygon points="302.53 164.3 272.52 146.99 262.51 152.76 292.52 170.07" fill="#D6D6D6"/><polygon points="312.53 146.99 282.52 129.67 272.52 135.44 302.53 152.76" fill="#D6D6D6"/><polygon points="312.53 135.44 302.53 129.67 312.53 123.9 322.54 129.67 332.54 123.9 302.53 106.59 282.52 118.13" fill="#D6D6D6"/><polygon points="302.53 129.67 312.53 135.44 322.54 129.67 312.53 123.9" fill="#D6D6D6"/><polygon points="332.54 146.99 342.54 141.22 342.54 164.3 362.55 152.76 342.54 141.22 332.54 135.44" fill="#D6D6D6"/><polygon points="452.59 170.07 502.61 141.22 502.61 129.67 492.61 135.44 492.61 135.44 492.61 123.9 492.61 123.9 492.61 123.9 452.59 146.99 452.59 146.99 452.59 146.99 452.59 135.44 442.59 141.22 412.58 158.53 412.58 146.99 402.57 152.76 382.56 164.3 382.56 152.76 372.56 158.53 362.55 164.3 362.55 152.76 342.54 164.3 342.54 141.22 332.54 146.99 332.54 135.44 332.54 123.9 322.54 129.67 312.53 135.44 312.53 135.44 312.53 146.99 302.53 152.76 302.53 164.3 292.52 170.07 292.52 181.62 272.52 193.16 272.52 216.25 262.51 222.02 262.51 245.11 242.5 256.65 242.5 233.56 242.5 233.56 242.5 233.56 232.5 239.33 232.5 227.79 222.49 233.56 222.49 222.02 222.49 210.48 202.48 222.02 202.48 233.56 182.48 245.11 182.48 256.65 172.47 262.42 172.47 273.96 172.47 273.96 162.47 279.74 162.47 291.28 142.46 302.82 142.46 291.28 132.46 297.05 122.45 302.82 122.45 314.37 102.44 325.91 102.44 337.45 182.48 291.28 192.48 285.51 192.48 297.05 222.49 279.74 232.5 273.96 232.5 285.51 272.52 262.42 282.52 256.65 282.52 268.19 372.56 216.25 382.56 210.48 382.56 222.02 422.58 198.93 422.58 187.39 442.59 175.85 442.59 164.3 452.59 158.53" fill="#fff"/><polygon points="472.36 578.82 452.35 567.28 452.35 578.82 482.36 596.14 482.36 584.6" fill="#A3A3A3"/><polygon points="502.37 561.51 472.36 544.2 472.36 555.74 502.37 573.05" fill="#A3A3A3"/><polygon points="492.37 578.83 492.37 578.82 482.36 584.6 472.36 578.82 472.36 578.82 482.36 584.6 482.38 584.6 482.38 584.6" fill="#A3A3A3"/><polygon points="502.37 596.14 502.37 584.6 492.37 590.37" fill="#A3A3A3"/><polygon points="522.39 573.06 532.38 578.82 532.38 567.29 522.39 573.05" fill="#A3A3A3"/><polygon points="502.37 561.51 502.38 561.52 502.38 561.51 512.38 555.74 512.38 555.74" fill="#A3A3A3"/><polygon points="522.38 538.42 492.37 521.11 492.37 532.65 522.38 549.97" fill="#A3A3A3"/><polygon points="582.41 515.34 562.4 503.79 562.4 515.34 572.41 521.11 572.42 521.11 572.42 521.12 592.41 532.65 592.41 521.11" fill="#A3A3A3"/><polygon points="582.41 503.79 602.42 515.34 602.42 492.25 572.4 474.94 572.4 498.02" fill="#A3A3A3"/><polygon points="612.42 532.65 612.42 521.17 602.47 526.91" fill="#A3A3A3"/><polygon points="602.47 515.37 602.42 515.34 582.41 503.79 582.41 503.79 602.42 515.34 592.41 521.11 582.41 515.34 582.41 515.34 592.41 521.11 592.48 521.15 592.48 521.13" fill="#A3A3A3"/><polygon points="642.43 526.88 642.43 515.4 632.48 521.14" fill="#A3A3A3"/><polygon points="612.42 474.94 582.41 457.62 582.41 469.16 612.42 486.48" fill="#A3A3A3"/><polygon points="632.43 463.39 632.48 463.42 632.5 463.41 632.5 463.43 642.49 469.2 642.5 469.19 642.5 469.2 652.44 474.94 652.44 463.39 622.42 446.08 622.42 457.62" fill="#A3A3A3"/><polygon points="682.45 434.53 652.44 417.22 652.44 428.76 682.45 446.08" fill="#A3A3A3"/><polygon points="732.47 474.94 732.47 463.45 722.52 469.2" fill="#A3A3A3"/><polygon points="702.46 411.45 672.44 394.13 672.44 405.68 702.46 422.99" fill="#A3A3A3"/><polygon points="722.47 388.36 692.45 371.04 692.45 382.59 722.47 399.9" fill="#A3A3A3"/><polygon points="742.48 365.27 712.46 347.96 712.46 359.5 742.48 376.82" fill="#A3A3A3"/><polygon points="752.48 347.96 722.47 330.64 722.47 342.19 752.48 359.5" fill="#A3A3A3"/><polygon points="762.48 330.64 732.47 313.33 732.47 324.87 762.48 342.19" fill="#A3A3A3"/><polygon points="772.49 463.39 772.49 451.91 762.54 457.65" fill="#A3A3A3"/><polygon points="482.36 584.6 492.37 578.82 502.37 573.05 472.36 555.74 452.35 567.28 472.36 578.82" fill="#D6D6D6"/><polygon points="512.38 555.74 522.38 549.97 492.37 532.65 472.36 544.2 502.37 561.51" fill="#D6D6D6"/><polygon points="532.38 532.65 512.38 521.11 522.38 515.34 512.38 509.56 492.37 521.11 522.38 538.42" fill="#D6D6D6"/><polygon points="532.38 532.65 532.39 532.66 542.4 526.88 542.4 538.42 572.4 521.11 542.39 503.79 522.38 515.34 512.38 521.11" fill="#D6D6D6"/><polygon points="622.42 469.16 612.42 463.39 622.42 457.62 632.43 463.39 632.43 463.39 622.42 457.62 602.42 446.08 582.41 457.62 612.42 474.94" fill="#D6D6D6"/><polygon points="612.42 486.48 582.41 469.16 572.4 474.94 602.42 492.25" fill="#D6D6D6"/><polygon points="592.41 521.11 602.42 515.34 582.41 503.79 572.4 498.02 562.4 503.79 582.41 515.34" fill="#D6D6D6"/><polygon points="632.5 474.96 642.49 469.2 632.5 463.43" fill="#D6D6D6"/><polygon points="642.5 469.2 642.5 480.67 652.44 474.94" fill="#D6D6D6"/><polygon points="622.42 457.62 612.42 463.39 622.42 469.16 622.48 469.2 632.48 463.42 632.43 463.39" fill="#D6D6D6"/><polygon points="682.45 446.08 652.44 428.76 622.42 446.08 652.44 463.39" fill="#D6D6D6"/><polygon points="702.46 422.99 672.44 405.68 652.44 417.22 682.45 434.53" fill="#D6D6D6"/><polygon points="722.47 399.9 692.45 382.59 672.44 394.13 702.46 411.45" fill="#D6D6D6"/><polygon points="742.48 376.82 712.46 359.5 692.45 371.04 722.47 388.36" fill="#D6D6D6"/><polygon points="772.49 324.87 752.48 313.33 762.48 307.56 752.48 301.78 732.47 313.33 762.48 330.64" fill="#D6D6D6"/><polygon points="752.48 359.5 722.47 342.19 712.46 347.96 742.48 365.27" fill="#D6D6D6"/><polygon points="762.48 342.19 732.47 324.87 722.47 330.64 752.48 347.96" fill="#D6D6D6"/><polygon points="772.49 324.87 772.54 324.9 782.56 319.12 782.56 330.6 802.5 319.1 782.49 307.56 792.5 301.78 782.49 296.01 762.48 307.56 752.48 313.33" fill="#D6D6D6"/><polygon points="802.5 319.1 802.56 319.13 812.58 313.35 812.58 324.83 842.52 307.56 822.51 296.01 832.51 290.24 822.51 284.47 792.5 301.78 782.49 307.56" fill="#D6D6D6"/><polygon points="852.59 301.82 852.59 313.29 862.53 307.56" fill="#D6D6D6"/><polygon points="842.52 307.56 842.57 307.59 852.58 301.82 842.52 296.01 852.52 290.24 842.52 284.47 832.51 290.24 822.51 296.01" fill="#D6D6D6"/><polygon points="872.6 301.82 872.6 313.29 882.54 307.56" fill="#D6D6D6"/><polygon points="842.52 296.01 852.58 301.82 852.59 301.81 852.59 301.82 862.53 307.56 862.58 307.59 872.58 301.82 862.53 296.01 872.53 290.24 862.53 284.47 852.52 290.24" fill="#D6D6D6"/><polygon points="892.61 301.82 892.66 313.26 902.54 307.56" fill="#D6D6D6"/><polygon points="862.53 296.01 872.58 301.82 872.6 301.81 872.6 301.82 882.54 307.56 882.59 307.59 892.59 301.82 882.54 296.01 892.54 290.24 912.55 301.78 912.55 301.78 882.54 284.47 872.53 290.24" fill="#D6D6D6"/><polygon points="922.55 307.56 912.62 301.82 912.67 313.26" fill="#D6D6D6"/><polygon points="882.54 296.01 892.59 301.82 892.61 301.81 892.61 301.82 902.54 307.56 902.6 307.59 912.6 301.82 912.55 301.78 892.54 290.24" fill="#D6D6D6"/><polygon points="572.41 521.11 542.4 538.42 542.4 538.42 542.4 526.88 532.39 532.66 522.39 538.42 522.39 549.97 512.38 555.74 502.38 561.51 502.38 561.52 502.38 573.05 492.37 578.83 482.38 584.6 482.38 584.6 482.38 596.14 492.37 590.37 502.37 584.6 502.38 584.6 502.38 596.14 522.39 584.6 522.39 573.06 522.39 573.05 532.38 567.29 532.4 567.28 532.4 578.82 552.41 567.28 552.41 555.74 562.41 549.97 562.41 538.42 572.42 532.65 572.42 521.12 572.42 521.11" fill="#fff"/><polygon points="712.53 486.5 712.53 474.96 722.52 469.2 732.47 463.45 732.54 463.41 732.54 474.96 762.54 457.65 772.49 451.91 772.56 451.87 772.56 463.41 832.58 428.78 832.58 417.24 862.6 399.92 862.6 388.38 873.28 382.22 872.6 371.07 882.6 365.3 882.6 353.75 892.61 347.98 892.61 336.44 922.62 319.12 922.62 307.58 912.67 313.32 912.67 313.26 912.62 301.82 912.62 301.81 912.6 301.82 902.6 307.59 892.66 313.32 892.66 313.26 892.61 301.82 892.61 301.81 892.59 301.82 882.59 307.59 872.6 313.35 872.6 313.29 872.6 301.82 872.6 301.81 872.58 301.82 862.58 307.59 852.59 313.35 852.59 313.29 852.59 301.82 852.59 301.81 852.58 301.82 842.57 307.59 812.58 324.89 812.58 324.83 812.58 313.35 802.56 319.13 782.56 330.66 782.56 330.6 782.56 319.12 772.54 324.9 762.6 330.64 762.55 342.21 752.55 347.98 752.55 359.52 742.54 365.3 742.54 376.84 722.54 388.38 722.54 399.92 702.53 411.47 702.53 423.01 682.52 434.56 682.52 446.1 652.51 463.41 652.51 474.96 642.5 480.73 642.5 480.67 642.5 469.2 642.5 469.19 642.49 469.2 632.5 474.96 632.5 463.43 632.5 463.41 632.48 463.42 622.48 469.2 612.49 474.96 612.49 486.5 602.48 492.27 602.48 515.36 602.47 515.37 592.48 521.13 592.48 521.15 592.48 532.67 602.47 526.91 612.42 521.17 612.49 521.13 612.49 532.67 632.48 521.14 642.43 515.4 642.5 515.36 642.5 526.9" fill="#fff"/><polygon points="134.36 841.54 114.84 830.31 114.84 841.82 144.85 859.14 144.85 847.59" fill="#A3A3A3"/><rect transform="matrix(-.8662 -.4997 .4997 -.8662 -133.81 1619)" x="144.08" y="827.39" width="11.55" height="0" fill="#A3A3A3"/><polygon points="164.86 847.59 174.86 853.36 174.86 841.82" fill="#A3A3A3"/><polygon points="134.85 795.7 134.85 807.19 164.86 824.5 164.86 812.96" fill="#A3A3A3"/><polygon points="214.88 830.28 224.89 836.05 224.89 824.5" fill="#A3A3A3"/><polygon points="154.86 772.61 154.86 784.1 184.87 801.42 184.87 789.88" fill="#A3A3A3"/><polygon points="264.9 801.42 274.91 807.19 274.91 795.65" fill="#A3A3A3"/><polygon points="204.67 755.18 204.71 755.15 184.87 743.73 184.87 755.24 214.88 772.56 214.88 761.05" fill="#A3A3A3"/><polygon points="184.87 743.7 184.87 743.7" fill="#A3A3A3"/><polygon points="154.86 830.28 144.85 824.5 144.33 824.21 124.84 813 124.84 824.5 154.86 841.82" fill="#A3A3A3"/><polygon points="144.87 847.58 154.86 841.82 124.75 824.46 114.72 830.24 114.84 830.31 134.36 841.54" fill="#D6D6D6"/><polygon points="154.87 830.27 164.86 824.5 134.75 807.14 124.73 812.93 124.84 813 144.33 824.21" fill="#D6D6D6"/><polygon points="184.87 801.42 154.76 784.06 134.64 795.58 134.85 795.7 164.86 812.96" fill="#D6D6D6"/><polygon points="214.88 772.56 184.78 755.2 154.65 772.49 154.86 772.61 184.87 789.88" fill="#D6D6D6"/><polygon points="214.74 749.39 194.87 737.93 184.87 743.7 184.87 743.7 184.85 743.71 184.87 743.73 204.71 755.15" fill="#D6D6D6"/><polygon points="204.71 755.15 204.67 755.18 214.88 761.05 214.88 761.02 224.89 755.24 224.89 766.79 234.89 761.02 234.89 772.56 264.86 755.27 264.7 755.18 274.78 749.4 244.8 732.11 214.74 749.39" fill="#D6D6D6"/><polygon points="294.92 749.48 294.92 772.56 314.92 761.02 314.92 761.02 314.92 761.02" fill="#D6D6D6"/><polygon points="264.86 755.27 274.91 749.47 274.91 761.02 294.91 749.48 284.82 743.66 274.78 749.4 264.7 755.18" fill="#D6D6D6"/><polygon points="294.92 772.56 294.92 749.48 294.92 749.47 294.91 749.48 274.91 761.02 274.91 749.47 264.86 755.27 234.89 772.56 234.89 761.02 224.89 766.79 224.89 755.24 214.88 761.02 214.88 761.05 214.88 772.56 184.87 789.88 184.87 801.42 164.86 812.96 164.86 824.5 154.87 830.27 154.86 830.28 154.86 830.28 154.86 841.82 144.87 847.58 144.85 847.59 144.85 859.14 164.86 847.59 174.86 841.82 174.86 853.36 214.88 830.28 224.89 824.5 224.89 836.05 254.9 818.73 254.9 807.19 264.9 801.42 274.91 795.65 274.91 807.19 304.92 789.88 304.92 778.33 314.92 772.56 314.92 761.02 314.92 761.02" fill="#fff"/><polygon points="679.59 82.249 649.69 64.997 649.69 64.876 649.68 64.875 629.68 76.433 659.7 93.748" fill="#D6D6D6"/><polygon points="679.71 70.764 679.71 70.662 709.66 53.382 679.71 36.031 649.69 53.453 679.7 70.768" fill="#D6D6D6"/><polygon points="719.72 24.494 739.73 36.034 739.73 36.031 709.72 18.716 699.72 24.494 709.72 30.263" fill="#D6D6D6"/><polygon points="719.72 47.575 729.68 41.83 719.72 36.061" fill="#D6D6D6"/><polygon points="709.71 41.87 709.72 41.865 709.72 41.803 719.7 36.046 709.72 30.266 709.72 30.263 699.72 24.494 689.71 18.716 679.71 24.488" fill="#D6D6D6"/><polygon points="749.73 41.806 739.73 36.037 739.73 47.575" fill="#D6D6D6"/><polygon points="719.72 36.061 729.68 41.83 739.73 36.034 719.72 24.494 709.72 30.263 709.72 30.266 719.7 36.046 719.72 36.031" fill="#D6D6D6"/><polygon points="789.75 18.716 759.74 1.401 749.74 7.173 779.75 24.488" fill="#D6D6D6"/><polygon points="802.19 0 777.32 0 789.75 7.173" fill="#D6D6D6"/><polygon points="659.7 93.748 629.68 76.433 629.68 87.977 659.7 105.29" fill="#A3A3A3"/><polygon points="679.59 82.249 679.61 82.26 679.7 82.209 679.7 70.768 649.69 53.453 649.69 64.876 649.69 64.997" fill="#A3A3A3"/><polygon points="719.64 59.169 709.72 64.89 709.72 64.89 719.72 70.763 719.72 70.662 719.72 59.22" fill="#A3A3A3"/><polygon points="709.71 53.351 709.71 41.87 679.71 24.488 679.71 36.031 709.66 53.382" fill="#A3A3A3"/><polygon points="749.74 7.173 749.74 18.716 779.75 36.031 779.75 24.488" fill="#A3A3A3"/><polygon points="789.75 18.716 789.75 7.173 777.32 0 759.74 0 759.74 1.401" fill="#A3A3A3"/><polygon points="829.77 7.173 839.78 12.945 839.78 1.401" fill="#A3A3A3"/><polygon points="809.76 7.173 819.77 12.945 819.77 1.401" fill="#A3A3A3"/><polygon points="789.75 18.716 779.75 24.488 779.75 36.031 809.76 18.716 809.76 7.173 819.77 1.401 819.77 12.945 829.77 7.173 839.78 1.401 839.78 12.945 862.21 0 802.19 0 789.75 7.173" fill="#fff"/><polygon points="729.68 41.83 719.72 47.575 719.72 36.061 719.72 36.031 719.7 36.046 709.72 41.803 709.72 41.865 709.72 53.347 709.71 53.351 709.66 53.382 679.71 70.662 679.71 70.764 679.71 82.205 679.7 82.209 679.61 82.26 659.7 93.748 659.7 105.29 699.72 82.205 699.72 70.662 709.72 64.89 719.64 59.169 719.72 59.118 719.72 59.22 719.72 70.662 749.74 53.347 749.74 41.803 749.73 41.806 739.73 47.575 739.73 36.037 739.73 36.031 739.73 36.034" fill="#fff"/><polygon points="1229.7 826.18 1229.7 837.72 1259.7 855 1259.7 843.48" fill="#A3A3A3"/><polygon points="1249.7 814.63 1279.7 831.9 1279.7 820.4 1249.7 803.08" fill="#A3A3A3"/><polygon points="1299.7 797.32 1299.6 797.29 1299.6 797.31 1269.7 780.06 1269.8 791.55 1299.7 808.82" fill="#A3A3A3"/><polygon points="1319.7 774.24 1319.7 774.23 1289.8 756.95 1289.8 768.49 1319.7 785.72 1319.6 774.18" fill="#A3A3A3"/><polygon points="1339.7 751.1 1339.7 751.08 1339.6 751.13 1309.8 733.9 1309.8 745.36 1339.7 762.6 1339.7 751.1" fill="#A3A3A3"/><polygon points="1349.6 745.27 1349.6 733.81 1319.6 716.5 1319.7 728.04 1319.7 728.02" fill="#A3A3A3"/><polygon points="1319.6 716.49 1319.6 716.5 1319.6 716.5" fill="#A3A3A3"/><polygon points="1399.7 704.93 1399.7 704.91 1399.6 704.94 1369.7 687.68 1369.7 699.16 1399.7 716.47" fill="#A3A3A3"/><polygon points="1389.8 664.54 1389.8 664.54 1389.8 664.54" fill="#A3A3A3"/><polygon points="1419.8 681.83 1389.8 664.54 1389.8 676.08 1419.8 693.36 1419.8 681.84" fill="#A3A3A3"/><polygon points="1449.8 664.53 1459.8 670.3 1459.8 670.3 1459.8 658.82 1429.8 641.51 1429.8 652.99 1449.8 664.53" fill="#A3A3A3"/><polygon points="1429.8 641.45 1429.8 641.51 1429.8 641.48" fill="#A3A3A3"/><polygon points="1479.8 635.71 1449.8 618.4 1449.8 629.94 1479.7 647.23 1479.8 647.21" fill="#A3A3A3"/><polygon points="1489.8 618.33 1459.9 601.08 1459.9 612.6 1489.8 629.83 1489.8 618.36" fill="#A3A3A3"/><polygon points="1459.9 601.06 1459.9 601.08 1459.9 601.07" fill="#A3A3A3"/><polygon points="1519.8 601.03 1519.8 589.54 1489.8 572.22 1489.8 583.72 1489.8 583.73 1489.8 583.72" fill="#A3A3A3"/><polygon points="1489.8 572.18 1489.8 572.22 1489.8 572.2" fill="#A3A3A3"/><polygon points="1609.8 583.6 1609.8 572.17 1599.4 566.18 1579.8 554.89 1579.8 566.4 1579.9 566.46 1580 566.41" fill="#A3A3A3"/><polygon points="1579.8 554.86 1579.8 554.89 1579.8 554.88" fill="#A3A3A3"/><polygon points="1629.8 572.06 1629.8 560.68 1599.9 543.42 1599.9 554.85 1600 554.82" fill="#A3A3A3"/><polygon points="1619.9 508.82 1620 508.76 1619.8 508.69 1619.9 531.77 1649.9 549.07 1649.9 526.08" fill="#A3A3A3"/><polygon points="1639.9 508.69 1668 524.88 1668 501.94 1639.9 485.73" fill="#A3A3A3"/><polygon points="1349.6 803 1349.6 791.58 1339.7 797.29" fill="#A3A3A3"/><polygon points="1319.7 785.73 1319.7 774.24 1319.6 774.18 1319.7 785.72 1319.7 785.73 1319.7 785.74" fill="#A3A3A3"/><polygon points="1429.7 756.91 1429.7 745.4 1429.7 745.39 1419.7 751.14" fill="#A3A3A3"/><polygon points="1519.7 693.38 1519.7 681.89 1509.8 687.64" fill="#A3A3A3"/><polygon points="1569.8 652.99 1579.8 658.75 1579.8 647.24" fill="#A3A3A3"/><polygon points="1639.9 635.68 1639.9 635.67 1639.9 635.67" fill="#A3A3A3"/><polygon points="1629.9 629.9 1639.8 635.65 1639.8 624.15" fill="#A3A3A3"/><polygon points="1299.7 808.82 1269.8 791.55 1269.7 791.51 1249.7 803.05 1279.7 820.36" fill="#D6D6D6"/><polygon points="1259.7 843.45 1279.7 831.92 1249.7 814.63 1229.7 826.18 1259.7 843.48" fill="#D6D6D6"/><polygon points="1299.6 797.29 1319.6 785.76 1289.6 768.45 1269.6 779.99 1269.7 780.06 1299.6 797.31" fill="#D6D6D6"/><polygon points="1339.7 762.64 1309.8 745.36 1289.8 756.9 1319.7 774.19 1339.7 762.65" fill="#D6D6D6"/><polygon points="1349.6 733.81 1359.7 728 1339.8 716.5 1349.7 710.76 1339.6 704.95 1319.6 716.5 1319.6 716.5 1319.6 716.5 1319.6 716.5" fill="#D6D6D6"/><polygon points="1339.7 751.08 1349.7 745.33 1349.6 745.27 1319.7 728.02 1319.7 728.04 1309.6 733.82 1309.8 733.9 1339.6 751.13" fill="#D6D6D6"/><polygon points="1359.7 728 1359.7 728.01 1369.7 722.25 1369.7 733.78 1369.7 733.78 1399.7 716.47 1369.7 699.16 1349.7 710.76 1339.8 716.5" fill="#D6D6D6"/><polygon points="1399.7 704.91 1419.7 693.4 1389.6 676.09 1369.6 687.63 1369.7 687.68 1399.6 704.94" fill="#D6D6D6"/><polygon points="1429.7 676.1 1409.7 664.54 1429.7 653 1449.7 664.55 1449.8 664.53 1429.8 652.99 1419.8 647.21 1389.8 664.54 1389.8 664.54 1419.8 681.83" fill="#D6D6D6"/><polygon points="1449.8 664.58 1449.8 676.05 1459.7 670.31" fill="#D6D6D6"/><polygon points="1409.7 664.54 1429.7 676.1 1449.7 664.55 1429.7 653" fill="#D6D6D6"/><polygon points="1459.8 658.76 1479.7 647.24 1449.8 629.96 1429.8 641.48 1429.8 641.51 1459.8 658.82" fill="#D6D6D6"/><polygon points="1519.8 601.04 1519.8 601.03 1489.8 583.72 1489.8 583.73 1459.9 601.07 1459.9 601.08 1489.8 618.33" fill="#D6D6D6"/><polygon points="1519.8 589.52 1519.8 589.5 1529.8 583.7 1510 572.22 1529.9 560.7 1519.8 554.87 1489.8 572.2 1489.8 572.22 1519.8 589.54" fill="#D6D6D6"/><polygon points="1529.8 583.7 1539.7 577.99 1529.8 572.22 1539.9 566.39 1530 560.68 1529.9 560.7 1510 572.22" fill="#D6D6D6"/><polygon points="1529.8 572.22 1539.7 577.99 1539.8 577.96 1539.8 577.95 1559.7 566.44 1549.8 560.68 1539.9 566.39" fill="#D6D6D6"/><polygon points="1579.8 589.4 1579.8 589.48 1579.9 589.44" fill="#D6D6D6"/><polygon points="1539.8 577.95 1539.8 577.96 1549.8 572.18 1549.8 583.72 1559.8 577.95 1559.8 589.5 1569.9 583.68 1560 577.95 1569.9 572.23 1559.8 566.41 1559.7 566.44" fill="#D6D6D6"/><polygon points="1560 577.95 1569.9 583.68 1579.8 577.95 1579.8 589.4 1579.9 589.44 1579.9 589.45 1589.8 583.72 1589.8 595.17 1589.9 595.22 1609.8 583.72 1609.8 583.63 1609.8 583.6 1580 566.41 1579.9 566.46 1569.9 572.23" fill="#D6D6D6"/><polygon points="1649.9 549.09 1619.9 531.82 1599.9 543.36 1629.8 560.64 1649.9 549.1" fill="#D6D6D6"/><polygon points="1639.9 485.69 1668 501.9 1668 501.75 1660 497.13 1668 492.5 1668 478.81 1659.9 474.15" fill="#D6D6D6"/><polygon points="1609.8 572.18 1609.8 572.18 1609.9 572.12 1589.9 560.61 1599.8 554.89 1589.8 549.11 1579.8 554.88 1579.8 554.89 1599.4 566.18" fill="#D6D6D6"/><polygon points="1649.9 526.08 1649.9 526.01 1649.9 525.98 1629.9 514.46 1639.8 508.74 1629.9 503.04 1620 508.76 1619.9 508.82" fill="#D6D6D6"/><polygon points="1639.9 508.67 1639.8 508.74 1629.9 514.46 1649.9 525.98 1659.9 520.24 1659.9 531.71 1659.9 531.74 1668 527.08 1668 524.88 1639.9 508.69" fill="#D6D6D6"/><polygon points="1609.9 572.12 1619.8 566.41 1619.8 577.81 1620 577.88 1629.8 572.18 1629.8 572.06 1600 554.82 1599.9 554.85 1599.8 554.89 1589.9 560.61" fill="#D6D6D6"/><polygon points="1489.8 629.87 1459.8 612.58 1449.8 618.37 1479.8 635.65 1489.8 629.9" fill="#D6D6D6"/><polygon points="1668 501.75 1668 492.5 1660 497.13" fill="#D6D6D6"/><polygon points="1659.9 531.78 1659.9 531.71 1659.9 520.24 1649.9 525.98 1649.9 526.01 1649.9 526.08 1649.9 549.07 1649.9 549.09 1649.9 549.1 1629.8 560.64 1629.8 560.64 1629.8 560.68 1629.8 572.06 1629.8 572.18 1620 577.88 1619.8 577.95 1619.8 577.81 1619.8 566.41 1609.9 572.12 1609.8 572.18 1609.8 572.18 1609.8 583.63 1609.8 583.72 1589.9 595.22 1589.8 595.27 1589.8 595.17 1589.8 583.72 1579.9 589.45 1579.8 589.5 1579.8 589.48 1579.8 589.4 1579.8 577.95 1569.9 583.68 1559.8 589.5 1559.8 577.95 1549.8 583.72 1549.8 572.18 1539.8 577.96 1539.7 577.99 1529.8 583.7 1519.8 589.5 1519.8 589.52 1519.8 601.04 1489.8 618.33 1489.8 618.36 1489.8 629.83 1489.8 629.87 1489.8 629.9 1479.8 635.65 1479.8 635.67 1479.8 635.71 1479.8 647.21 1479.7 647.23 1479.7 647.24 1459.8 658.76 1459.8 658.82 1459.8 670.3 1459.8 670.3 1449.8 676.07 1449.8 676.05 1449.8 664.58 1449.8 664.53 1449.8 664.53 1449.7 664.55 1429.7 676.1 1419.8 681.83 1419.8 681.84 1419.8 693.36 1419.8 693.39 1399.7 704.93 1399.7 716.47 1369.7 733.78 1369.7 733.79 1369.7 733.78 1369.7 722.25 1359.7 728.01 1349.7 733.79 1349.7 745.33 1339.7 751.1 1339.7 751.1 1339.7 762.6 1339.7 762.64 1339.7 762.65 1319.7 774.19 1319.7 774.19 1319.7 774.23 1319.7 774.24 1319.7 785.73 1319.7 785.74 1299.7 797.28 1299.7 797.32 1299.7 808.82 1279.7 820.36 1279.7 820.4 1279.7 831.91 1279.7 831.92 1259.7 843.45 1259.7 843.48 1259.7 855 1319.7 820.39 1319.7 808.85 1339.7 797.29 1349.6 791.58 1349.7 791.53 1349.7 803.08 1379.7 785.76 1379.7 774.22 1419.7 751.14 1429.7 745.39 1429.7 745.36 1429.7 756.9 1459.8 739.59 1459.8 728.04 1469.8 722.27 1469.8 710.73 1509.8 687.64 1519.7 681.89 1519.8 681.87 1519.8 693.41 1569.8 664.55 1569.8 653.01 1569.8 652.99 1579.8 647.24 1579.8 658.75 1579.8 658.78 1629.9 629.9 1639.8 624.15 1639.8 635.65 1639.8 635.7 1639.9 635.67 1639.9 635.67 1668 619.45 1668 527.08 1659.9 531.74" fill="#fff"/><polygon points="1451.5 154.1 1421.5 136.79 1421.5 148.33 1451.5 165.65" fill="#A3A3A3"/><polygon points="1451.5 131.02 1471.5 142.56 1471.5 131.02 1441.5 113.7 1441.5 125.24" fill="#A3A3A3"/><polygon points="1471.5 154.1 1481.5 159.88 1481.5 148.33" fill="#A3A3A3"/><rect x="1461.5" y="125.24" width="0" height="23.1" fill="#A3A3A3"/><polygon points="1501.5 136.79 1511.5 142.56 1511.5 131.02" fill="#A3A3A3"/><polygon points="1501.5 102.16 1471.5 84.843 1471.5 96.386 1501.5 113.7" fill="#A3A3A3"/><polygon points="1111.4 304.17 1111.4 315.71 1141.4 333.02 1141.4 321.48" fill="#A3A3A3"/><polygon points="1151.4 304.17 1121.4 286.85 1121.4 298.4 1151.4 315.71" fill="#A3A3A3"/><polygon points="1151.4 292.62 1161.4 298.4 1161.4 286.85 1131.4 269.54 1131.4 281.08" fill="#A3A3A3"/><polygon points="1171.4 315.71 1181.4 321.48 1181.4 309.94" fill="#A3A3A3"/><rect transform="matrix(-.8662 -.4997 .4997 -.8662 2010.3 1129.3)" x="1150.6" y="295.51" width="11.55" height="0" fill="#A3A3A3"/><polygon points="1221.4 286.85 1231.4 292.62 1231.4 281.08" fill="#A3A3A3"/><polygon points="1181.4 263.76 1171.4 269.54 1181.4 275.31" fill="#A3A3A3"/><polygon points="1171.4 269.54 1171.4 257.99 1141.4 240.68 1141.4 252.22 1151.4 257.99 1151.4 257.99" fill="#A3A3A3"/><polygon points="1181.4 229.14 1151.4 211.82 1151.4 234.91 1181.4 252.22" fill="#A3A3A3"/><polygon points="1191.4 211.82 1161.4 194.5 1161.4 206.05 1191.4 223.36" fill="#A3A3A3"/><polygon points="1211.4 188.73 1181.4 171.42 1181.4 182.96 1211.4 200.28" fill="#A3A3A3"/><polygon points="1231.4 165.65 1201.4 148.33 1201.4 159.88 1231.4 177.19" fill="#A3A3A3"/><polygon points="1341.4 240.68 1351.5 246.45 1351.5 234.91" fill="#A3A3A3"/><polygon points="1271.4 269.54 1281.4 275.31 1281.4 263.76" fill="#A3A3A3"/><polygon points="1151.4 315.71 1121.4 298.4 1111.4 304.17 1141.4 321.48" fill="#D6D6D6"/><polygon points="1161.4 298.4 1151.4 292.62 1131.4 281.08 1121.4 286.85 1151.4 304.17" fill="#D6D6D6"/><polygon points="1181.4 275.31 1171.4 269.54 1171.4 269.54 1171.4 269.54 1151.4 257.99 1151.4 257.99 1131.4 269.54 1161.4 286.85" fill="#D6D6D6"/><polygon points="1181.4 252.22 1151.4 234.91 1141.4 240.68 1171.4 257.99" fill="#D6D6D6"/><polygon points="1191.4 223.36 1161.4 206.05 1151.4 211.82 1181.4 229.14" fill="#D6D6D6"/><polygon points="1211.4 200.28 1181.4 182.96 1161.4 194.5 1191.4 211.82" fill="#D6D6D6"/><polygon points="1231.4 177.19 1201.4 159.88 1181.4 171.42 1211.4 188.73" fill="#D6D6D6"/><polygon points="1241.4 159.88 1221.4 148.33 1231.4 142.56 1221.4 136.79 1201.4 148.33 1231.4 165.65" fill="#D6D6D6"/><polygon points="1241.4 159.88 1251.4 154.1 1251.4 165.65 1261.4 159.88 1241.4 148.33 1251.4 142.56 1241.4 136.79 1231.4 142.56 1221.4 148.33" fill="#D6D6D6"/><polygon points="1261.4 159.88 1271.4 154.1 1271.4 165.65 1281.4 159.88 1261.4 148.33 1271.4 142.56 1261.4 136.79 1251.4 142.56 1241.4 148.33" fill="#D6D6D6"/><polygon points="1331.4 154.1 1321.4 148.33 1321.5 159.86" fill="#D6D6D6"/><polygon points="1331.4 177.19 1341.5 171.41 1331.4 165.63" fill="#D6D6D6"/><polygon points="1281.4 159.88 1291.4 154.1 1291.4 165.65 1321.4 148.33 1291.4 131.02 1271.4 142.56 1261.4 148.33" fill="#D6D6D6"/><polygon points="1381.5 171.42 1381.5 171.42" fill="#D6D6D6"/><polygon points="1331.4 154.1 1331.4 165.63 1341.5 171.41 1351.5 165.65 1351.5 177.18 1351.5 177.19 1371.5 165.65 1361.5 159.88 1371.5 154.1 1351.5 142.56 1331.4 154.1 1321.5 159.86" fill="#D6D6D6"/><polygon points="1391.5 177.19 1401.5 171.42 1391.5 165.65" fill="#D6D6D6"/><polygon points="1381.5 159.88 1381.5 171.42 1381.5 171.42 1381.5 171.42 1391.5 165.65" fill="#D6D6D6"/><polygon points="1371.5 165.65 1381.5 159.88 1391.5 154.1 1381.5 148.33 1371.5 154.1 1361.5 159.88" fill="#D6D6D6"/><polygon points="1381.5 159.88 1391.5 165.65 1391.5 165.65 1391.5 165.65 1401.5 171.42 1411.5 165.65 1411.5 177.19 1431.5 165.65 1401.5 148.33 1391.5 154.1" fill="#D6D6D6"/><polygon points="1471.5 142.56 1451.5 131.02 1441.5 125.24 1421.5 136.79 1451.5 154.1" fill="#D6D6D6"/><polygon points="1531.5 107.93 1521.5 102.16 1521.5 113.7" fill="#D6D6D6"/><polygon points="1501.5 102.16 1511.5 96.386 1511.5 96.386 1521.5 90.614 1491.5 73.299 1471.5 84.843" fill="#D6D6D6"/><polygon points="1501.5 113.7 1471.5 96.386 1441.5 113.7 1471.5 131.02" fill="#D6D6D6"/><polygon points="1511.5 96.386 1521.5 90.614 1521.5 102.16 1531.5 107.93 1541.5 102.16 1541.5 113.7 1561.5 102.16 1531.5 84.843 1521.5 90.614" fill="#D6D6D6"/><polygon points="1231.4 281.08 1231.4 292.62 1271.4 269.54 1281.4 263.76 1281.4 275.31 1341.4 240.68 1351.5 234.91 1351.5 246.45 1391.5 223.36 1391.5 211.82 1421.5 194.5 1421.5 182.96 1431.5 177.19 1431.5 165.65 1411.5 177.19 1411.5 165.65 1401.5 171.42 1391.5 177.19 1391.5 165.65 1391.5 165.65 1391.5 165.65 1381.5 171.42 1381.5 171.42 1381.5 171.42 1381.5 171.42 1381.5 159.88 1371.5 165.65 1351.5 177.19 1351.5 177.19 1351.5 177.18 1351.5 165.65 1341.5 171.41 1331.4 177.19 1331.4 165.63 1331.4 154.1 1321.5 159.86 1321.4 148.33 1291.4 165.65 1291.4 154.1 1281.4 159.88 1271.4 165.65 1271.4 154.1 1261.4 159.88 1251.4 165.65 1251.4 154.1 1241.4 159.88 1231.4 165.65 1231.4 177.19 1211.4 188.73 1211.4 200.28 1191.4 211.82 1191.4 223.36 1181.4 229.14 1181.4 252.22 1171.4 257.99 1171.4 257.99 1171.4 269.54 1171.4 269.54 1171.4 269.54 1181.4 263.76 1181.4 275.31 1161.4 286.85 1161.4 298.4 1161.4 298.4 1151.4 304.17 1151.4 315.71 1141.4 321.48 1141.4 333.02 1171.4 315.71 1181.4 309.94 1181.4 321.48 1211.4 304.17 1211.4 292.62 1221.4 286.85" fill="#fff"/><polygon points="1541.5 102.16 1531.5 107.93 1521.5 113.7 1521.5 102.16 1521.5 90.614 1511.5 96.386 1501.5 102.16 1501.5 102.16 1501.5 113.7 1471.5 131.02 1471.5 142.56 1471.5 142.56 1451.5 154.1 1451.5 165.65 1471.5 154.1 1481.5 148.33 1481.5 159.88 1491.5 154.1 1491.5 142.56 1501.5 136.79 1511.5 131.02 1511.5 142.56 1561.5 113.7 1561.5 102.16 1541.5 113.7" fill="#fff"/></svg>
</file>

<file path="src/docs/images/logo.svg">
<?xml version="1.0" encoding="UTF-8"?><svg version="1.1" viewBox="0 0 440.104 552.999" xmlns="http://www.w3.org/2000/svg"><path d="m125.48 540.64l-5.332 3.091-5.333 3.091-5.332 3.09-5.333 3.091-6.442-3.841-6.442-3.84-6.442-3.84-6.442-3.841-6.442-3.84-6.442-3.84-6.442-3.841 5.333-3.09 6.442 3.84 6.442 3.84 5.332-3.09 5.333-3.091 5.332-3.091 5.333-3.09 6.442 3.84 6.442 3.841 6.442 3.841 6.442 3.84 6.442 3.84-5.333 3.09zm-11.774-0.749l5.332-3.091-6.442-3.84-6.442-3.84-6.442-3.841-5.332 3.091-5.333 3.09-5.332 3.091 6.442 3.84 6.442 3.841 6.442 3.84 5.332-3.091 5.333-3.09z" fill="#0A323D"/><path d="m136.15 534.46l-6.442-3.841-6.442-3.84-6.442-3.841-6.442-3.84-6.442-3.84 5.333-3.091 5.333-3.091 5.333-3.09 5.333-3.091 6.442 3.841-5.333 3.09-5.333 3.091-5.333 3.09 6.442 3.841 6.442 3.84 6.442 3.84 6.442 3.841-5.333 3.091z" fill="#0A323D"/><path d="m184.14 506.64l-5.333 3.09-5.333 3.091-5.332 3.09-5.333 3.091-6.442-3.841-6.442-3.84-6.442-3.84-6.442-3.841-6.442-3.84 5.333-3.091 5.332-3.09 5.333-3.091 5.333-3.09 5.333-3.091 6.442 3.841 6.442 3.84 6.442 3.841 6.442 3.84 6.442 3.84-5.333 3.091zm-11.775-0.75l5.332-3.091-6.441-3.84-6.443-3.84-6.441-3.841-5.333 3.091-5.333 3.09-5.332 3.091 6.442 3.84 6.442 3.841 6.442 3.84 5.332-3.091 5.333-3.09z" fill="#0A323D"/><path d="m216.14 488.1l-5.333 3.09-5.332 3.09-5.333 3.091-5.333 3.091-6.441-3.841-6.443-3.84-6.441-3.84-6.443-3.841-6.441-3.84 5.332-3.091 6.442 3.841 6.442 3.84 6.442 3.841 6.442 3.84 5.332-3.091-6.441-3.84-6.443-3.84-6.441-3.841 5.332-3.091 6.442 3.841 6.442 3.841 6.442 3.84 5.333-3.091-6.442-3.84-6.442-3.841-6.442-3.84-6.442-3.84 5.332-3.091 6.442 3.84 6.442 3.841 6.442 3.84 6.442 3.84 6.442 3.841-5.332 3.091z" fill="#0A323D"/><path d="m248.13 469.56l-5.332 3.091-5.333 3.09-5.333 3.091-5.332 3.09-6.442-3.84 5.332-3.091 5.333-3.09 5.332-3.091 5.333-3.09-6.442-3.84-5.332 3.09-5.333 3.091-5.333 3.09-5.332 3.091-6.442-3.841-6.442-3.84-6.442-3.841 5.332-3.09 5.333-3.091 5.332-3.09 5.333-3.091 5.333-3.09 6.441 3.84-5.332 3.091-5.332 3.09-5.333 3.091-5.333 3.09 6.442 3.841 5.333-3.091 5.332-3.09 5.333-3.091 5.333-3.09 6.441 3.84 6.443 3.84 6.441 3.841-5.332 3.09z" fill="#0A323D"/><path d="m273.68 447.18l5.333-3.091 6.442 3.84-5.333 3.091-5.332 3.091-5.333 3.09-5.332 3.091-5.333 3.09-6.442-3.84-6.442-3.84-6.442-3.841-6.442-3.84-6.442-3.841 5.333-3.09 5.332-3.091 5.333-3.09 5.332-3.091 5.333-3.091 6.442 3.841 6.442 3.841 6.442 3.84-5.333 3.091-5.332 3.09-5.333 3.091-5.332 3.09 6.442 3.84 5.332-3.09 5.333-3.091 5.332-3.09zm-18.216-4.59l5.332-3.091-6.442-3.84-5.332 3.09-5.333 3.091-5.332 3.09 6.442 3.841 5.332-3.091 5.333-3.09z" fill="#0A323D"/><path d="m290.79 444.84l-6.441-3.84-6.443-3.84-6.441-3.841-6.443-3.841-6.441-3.84 5.332-3.09 5.332-3.091 5.333-3.091 5.333-3.09 6.441 3.84-5.332 3.091-5.332 3.09-5.333 3.091 6.442 3.84 6.442 3.841 6.442 3.84 6.442 3.841-5.333 3.09z" fill="#0A323D"/><path d="m338.78 417.02l-5.332 3.091-5.333 3.09-5.332 3.091-5.333 3.09-6.442-3.84 5.333-3.091 5.332-3.09 5.333-3.091 5.332-3.09-6.442-3.84-5.332 3.09-5.333 3.091-5.332 3.09-5.333 3.091-6.442-3.841-6.442-3.84-6.442-3.841 5.333-3.09 5.332-3.091 5.333-3.09 5.332-3.091 5.333-3.09 6.442 3.84-5.333 3.091-5.332 3.09-5.333 3.091-5.332 3.09 6.442 3.841 5.332-3.091 5.333-3.09 5.332-3.091 5.333-3.09 6.442 3.84 6.442 3.84 6.442 3.841-5.333 3.09z" fill="#0A323D"/><path d="m383.66 406.16l-5.333 3.091-5.333 3.091-5.332 3.09-5.332 3.091-6.443-3.84 5.333-3.091 5.333-3.09 5.332-3.091 5.333-3.091-6.441-3.84-5.333 3.09-5.332 3.091-5.333 3.091-5.333 3.09-6.441-3.84-6.443-3.84-6.441-3.841-6.443-3.84-6.441-3.841 5.332-3.09 6.442 3.84 6.442 3.841 6.442 3.84 6.442 3.84 5.332-3.09 5.333-3.091 5.333-3.09-6.442-3.84-6.442-3.841-6.442-3.841-6.442-3.84 5.332-3.09 6.442 3.84 6.442 3.84 6.442 3.841 6.442 3.84 6.442 3.841 6.441 3.84 6.442 3.84-5.332 3.09z" fill="#0A323D"/><path d="m402.78 379.94l-6.442-3.841-6.442-3.84-6.442-3.84-6.442-3.841-5.332 3.091-5.333 3.09-5.333 3.091 6.442 3.84 6.442 3.841 6.442 3.84 6.442 3.84-5.332 3.091-6.442-3.841-6.442-3.84-6.442-3.84-6.442-3.841-6.442-3.84 5.332-3.091 5.333-3.09 5.332-3.091 5.333-3.09 5.333-3.091 6.441 3.841 6.443 3.84 6.441 3.841 6.443 3.84 6.441 3.84-5.332 3.091z" fill="#0A323D"/><path d="m415.44 349.88l-6.442-3.841-5.332 3.091-5.333 3.09-5.332 3.091 6.441 3.84 6.443 3.841 6.441 3.84 5.333-3.091 5.333-3.09 5.332-3.091-6.442-3.84 5.333-3.09 6.442 3.84 6.442 3.84-5.333 3.091-5.332 3.09-5.333 3.091-5.332 3.09-5.333 3.091-6.442-3.841-6.442-3.84-6.442-3.84-6.442-3.841-6.442-3.84 5.332-3.091 5.333-3.09 5.333-3.091 5.332-3.09 5.333-3.091 6.442 3.841 6.442 3.84-5.333 3.091z" fill="#0A323D"/><polygon points="306.04 147.19 204.53 88.193 204.36 29.494 305.88 88.487" fill="#0A323D"/><polygon points="306.71 382.01 205.19 323.02 205.03 264.32 306.54 323.31" fill="#0A323D"/><polygon points="255.46 352.81 153.94 293.81 153.78 235.11 255.29 294.11" fill="#0A323D"/><polygon points="255.12 235.41 153.61 176.41 153.44 117.69 254.96 176.68" fill="#0A323D"/><polygon points="204.21 323.6 102.69 264.61 102.52 205.91 204.04 264.9" fill="#0A323D"/><polygon points="153.29 411.79 51.773 352.8 51.606 294.1 153.12 353.09" fill="#0A323D"/><polygon points="152.96 294.39 51.44 235.4 51.274 176.67 152.79 235.67" fill="#0A323D"/><polygon points="101.68 265.18 0.166 206.18 0 147.48 101.52 206.48" fill="#0A323D"/><polygon points="102.35 500 0.832 441.01 0.666 382.31 102.18 441.3" fill="#0A323D"/><polygon points="305.88 88.487 204.36 29.494 255.44 0 356.96 58.994" fill="#267D91"/><polygon points="306.54 323.31 205.03 264.32 256.11 234.82 357.62 293.82" fill="#267D91"/><polygon points="255.29 294.11 153.78 235.11 204.86 205.62 306.37 264.61" fill="#267D91"/><polygon points="254.96 176.68 153.44 117.69 204.53 88.193 306.04 147.19" fill="#267D91"/><polygon points="204.04 264.9 102.52 205.91 153.61 176.41 255.12 235.41" fill="#267D91"/><polygon points="153.12 353.09 51.606 294.1 102.69 264.61 204.21 323.6" fill="#267D91"/><polygon points="152.79 235.67 51.274 176.67 102.36 147.18 203.87 206.17" fill="#267D91"/><polygon points="101.52 206.48 0 147.48 51.107 117.97 152.62 176.97" fill="#267D91"/><polygon points="102.18 441.3 0.666 382.31 51.773 352.8 153.29 411.79" fill="#267D91"/><polygon points="356.96 58.994 357.12 117.69 306.04 147.19 305.88 88.487" fill="#71D2E2"/><polygon points="357.62 293.82 357.79 352.52 306.71 382.01 306.54 323.31" fill="#71D2E2"/><polygon points="306.37 264.61 306.54 323.31 255.46 352.81 255.29 294.11" fill="#71D2E2"/><polygon points="306.04 147.19 306.21 205.91 255.12 235.41 254.96 176.68" fill="#71D2E2"/><polygon points="255.12 235.41 255.29 294.11 204.21 323.6 204.04 264.9" fill="#71D2E2"/><polygon points="204.21 323.6 204.37 382.3 153.29 411.79 153.12 353.09" fill="#71D2E2"/><polygon points="203.87 206.17 204.04 264.9 152.96 294.39 152.79 235.67" fill="#71D2E2"/><polygon points="152.62 176.97 152.79 235.67 101.68 265.18 101.52 206.48" fill="#71D2E2"/><polygon points="153.29 411.79 153.45 470.49 102.35 500 102.18 441.3" fill="#71D2E2"/></svg>
</file>

<file path="src/docs/index.html">
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex" />
  <link rel="icon" type="image/png" href="./images/icon-128.png" sizes="128x128">
  <title>xBrowserSync API</title>
</head>

<body id="home" class="index">
  <div class="background">
    <div class="background-img"></div>
  </div>

  <button type="button" class="nav-menu-button">
    <span class="hamburger" aria-hidden="true"></span>
    <span class="sr-only">Menu</span>
  </button>

  <nav id="mainNav" class="navbar navbar-expand-md navbar-default navbar-fixed-top navbar-custom affix">
    <div class="container">
      <div class="collapse navbar-collapse" id="navbar">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link" href="#home">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#status">Status</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#bookmarks">Bookmarks</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#serviceinfo">Service Information</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <header>
    <div class="container">
      <div class="row">
        <div class="col-md-4 offset-md-2">
          <h1>xBrowserSync</h1>
        </div>
        <div class="title col-md-6">
          <h2>API service info</h2>
        </div>
      </div>
    </div>
  </header>

  <section id="status" class="dark">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 offset-lg-2 serviceinfo offline">
          <div class="status">
            <span>
              <strong>Status:</strong>
              <span id="currentstatus"></span>
            </span>
            <span id="location">
              <strong>Location:</strong>
              <span></span>
            </span>
            <span class="version">
              <strong>Version:</strong>
              <span id="version"></span>
            </span>
          </div>
          <div id="servermessage"></div>
        </div>
      </div>
      <div class="row">
        <div class="col-lg-8 offset-lg-2">
          <p>This xBrowserSync service provides a REST API that xBrowserSync clients can sync to. The available API
            methods
            are listed below.</p>
          <p>For more information visit the
            <a href="https://www.xbrowsersync.org/">xBrowserSync website</a> or check out the
            <a href="https://github.com/xbrowsersync/api">API GitHub repo</a>.
          </p>
        </div>
      </div>
    </div>
  </section>

  <section id="bookmarks">
    <div class="container">
      <div class="panel">
        <h3>Bookmarks</h3>
        <div class="header">
          <h4>Create bookmarks</h4>
          <div>
            <span class="label label-warning">Post</span>
            <code>/bookmarks</code>
          </div>
        </div>
        <p>Creates a new (empty) bookmark sync and returns the corresponding ID.</p>
        <div class="example">
          <p>Post body example:</p>
          <pre><code>{
    "version":"1.0.0"
}</code></pre>
          <ul>
            <li>
              <strong>version:</strong> Version number of the xBrowserSync client used to create the sync.
            </li>
          </ul>
          <p>Response example:</p>
          <pre><code>{
    "id":"52758cb942814faa9ab255208025ae59",
    "lastUpdated":"2016-07-06T12:43:16.866Z",
    "version":"1.0.0"
}</code></pre>
          <ul>
            <li>
              <strong>id:</strong> 32 character alphanumeric sync ID.
            </li>
            <li>
              <strong>lastUpdated:</strong> Last updated timestamp for created bookmarks.
            </li>
            <li>
              <strong>version:</strong>Version number of the xBrowserSync client used to create the sync.
            </li>
          </ul>
        </div>

        <div class="header">
          <h4>Get bookmarks</h4>
          <div>
            <span class="label label-success">Get</span>
            <code>/bookmarks/{id}</code>
          </div>
        </div>
        <p>Retrieves the bookmark sync corresponding to the provided sync ID.</p>
        <div class="example">
          <p>Query params:</p>
          <ul>
            <li>
              <strong>id:</strong> 32 character alphanumeric sync ID.
            </li>
          </ul>
          <p>Response example:</p>
          <pre><code>{
    "bookmarks":"DWCx6wR9ggPqPRrhU4O4oLN5P09oULX4Xt+ckxswtFNds...",
    "lastUpdated":"2016-07-06T12:43:16.866Z",
    "version":"1.0.0"
}</code></pre>
          <ul>
            <li>
              <strong>bookmarks:</strong> Encrypted bookmark data salted using secret value.
            </li>
            <li>
              <strong>lastUpdated:</strong> Last updated timestamp for retrieved bookmarks.
            </li>
            <li>
              <strong>version:</strong> Version number of the xBrowserSync client used to create the sync.
            </li>
          </ul>
        </div>

        <div class="header">
          <h4>Update bookmarks</h4>
          <div>
            <span class="label label-info">Put</span>
            <code>/bookmarks/{id}</code>
          </div>
        </div>
        <p>Updates the bookmark sync data corresponding to the provided sync ID with the provided encrypted bookmarks
          data.</p>
        <div class="example">
          <p>Query params:</p>
          <ul>
            <li>
              <strong>id:</strong> 32 character alphanumeric sync ID.
            </li>
          </ul>
          <p>Post body example:</p>
          <pre><code>{
    "bookmarks":"DWCx6wR9ggPqPRrhU4O4oLN5P09oULX4Xt+ckxswtFNds...",
    "lastUpdated":"2016-07-06T12:43:16.866Z",
}</code></pre>
          <ul>
            <li>
              <strong>bookmarks:</strong> Encrypted bookmark data salted using secret value.
            </li>
            <li>
              <strong>lastUpdated:</strong> Last updated timestamp to check against existing bookmarks.
            </li>
          </ul>
          <p>Response example:</p>
          <pre><code>{
    "lastUpdated":"2016-07-06T12:43:16.866Z"
}</code></pre>
          <ul>
            <li>
              <strong>lastUpdated:</strong> Last updated timestamp for updated bookmarks.
            </li>
          </ul>
        </div>

        <div class="header">
          <h4>Get last updated</h4>
          <div>
            <span class="label label-success">Get</span>
            <code>/bookmarks/{id}/lastUpdated</code>
          </div>
        </div>
        <p>Retrieves the bookmark sync last updated timestamp corresponding to the provided sync ID.</p>
        <div class="example">
          <p>Query params:</p>
          <ul>
            <li>
              <strong>id:</strong> 32 character alphanumeric sync ID.
            </li>
          </ul>
          <p>Response example:</p>
          <pre><code>{
    "lastUpdated":"2016-07-06T12:43:16.866Z"
}</code></pre>
          <ul>
            <li>
              <strong>lastUpdated:</strong> Last updated timestamp for corresponding bookmarks.
            </li>
          </ul>
        </div>

        <div class="header">
          <h4>Get sync version</h4>
          <div>
            <span class="label label-success">Get</span>
            <code>/bookmarks/{id}/version</code>
          </div>
        </div>
        <p>Retrieves the bookmark sync version number of the xBrowserSync client used to create the bookmarks sync
          corresponding
          to the provided sync ID.</p>
        <div class="example">
          <p>Query params:</p>
          <ul>
            <li>
              <strong>id:</strong> 32 character alphanumeric sync ID.
            </li>
          </ul>
          <p>Response example:</p>
          <pre><code>{
    "version":"1.0.0"
}</code></pre>
          <ul>
            <li>
              <strong>version:</strong> Version number of the xBrowserSync client used to create the sync.
            </li>
          </ul>
        </div>

      </div>
    </div>
  </section>

  <section id="serviceinfo">
    <div class="container">
      <div class="panel">
        <h3>Service information</h3>
        <div class="header">
          <h4>Get service information</h4>
          <div>
            <span class="label label-success">Get</span>
            <code>/info</code>
          </div>
        </div>
        <p>Retrieves information describing the xBrowserSync service.</p>
        <div class="example">
          <p>Response example:</p>
          <pre><code>{
    "maxSyncSize":204800,
    "message":"",
    "status":1,
    "version":"1.0.0"
}</code></pre>
          <ul>
            <li>
              <strong>status:</strong> Current service status code. 1 = Online; 2 = Offline; 3 = Not accepting new
              syncs.
            </li>
            <li>
              <strong>message:</strong> Service information message.
            </li>
            <li>
              <strong>version:</strong> API version service is using.
            </li>
            <li>
              <strong>maxSyncSize:</strong> Maximum sync size (in bytes) allowed by the service.
            </li>
          </ul>
        </div>
      </div>
    </div>
  </section>
</body>

</html>
</file>

<file path="src/docs/index.ts">
import 'bootstrap/dist/css/bootstrap.min.css';
import 'typeface-roboto-condensed';
import DOMPurify from 'dompurify';
import marked from 'marked';
import SmoothScroll from 'smooth-scroll';
import { getCountryNameFromLocationCode, setCountryNames } from '../location';
import { IGetInfoResponse } from '../services/info.service';

// API home page and documentation
class DocsPage {
  // Initialises the page once DOM is ready
  init = async (): Promise<void> => {
    // Enable resonsive menu
    this.enableMenu();

    // Update list of country names where necessary
    setCountryNames();

    // Check service status
    this.checkStatus();

    // Enable smooth scrolling of page links
    SmoothScroll('a[href*="#"]', {
      updateURL: false,
    });
  };

  private async checkStatus() {
    const serviceInfoEl = document.querySelector('.serviceinfo');
    const versionEl = document.querySelector('#version');
    const currentStatusEl = document.querySelector('#currentstatus');
    const serverMessageEl = document.querySelector('#servermessage');
    const locationEl = document.querySelector('#location');

    // Display current status and version for this xBrowserSync service
    try {
      const response = await fetch(`${window.location.pathname}info`);
      if (!response.ok) {
        throw new Error(response.statusText);
      }

      // Display service info block
      serviceInfoEl.classList.remove('offline');

      const apiInfo: IGetInfoResponse = await response.json();
      if (apiInfo) {
        versionEl.textContent = apiInfo.version;

        // If the server has configured a location, display it
        if (apiInfo.location) {
          locationEl.querySelector('span').innerText = getCountryNameFromLocationCode(apiInfo.location);
          locationEl.classList.add('d-block');
        }

        // If the server has configured a message, display it
        if (apiInfo.message) {
          serverMessageEl.innerHTML = DOMPurify.sanitize(marked(apiInfo.message), {});
        }
      }

      switch (apiInfo.status) {
        case 1:
          currentStatusEl.textContent = 'Online';
          currentStatusEl.className = 'text-success';
          break;
        case 3:
          currentStatusEl.textContent = 'Not accepting new syncs';
          currentStatusEl.className = 'text-warning';
          break;
        default:
        case 2:
          currentStatusEl.textContent = 'Offline';
          currentStatusEl.className = 'text-danger';
          break;
      }
    } catch (err) {
      currentStatusEl.textContent = 'Offline';
      currentStatusEl.className = 'text-danger';
      // eslint-disable-next-line no-console
      console.error(err);
    }
  }

  private enableMenu() {
    const toggle = document.querySelector<HTMLButtonElement>('.nav-menu-button');
    const navbar = document.querySelector('nav');

    const toggleMenu = () => {
      // Toggle menu display and menu button hide
      if (navbar.classList.contains('open')) {
        navbar.classList.remove('open');
        toggle.classList.remove('hide');
        document.body.classList.remove('noscroll');
      } else {
        navbar.classList.add('open');
        toggle.classList.add('hide');
        document.body.classList.add('noscroll');
      }
    };

    // Enable menu button
    toggle.addEventListener('click', () => {
      toggleMenu();
    });

    // Hide menu when nav link is clicked
    const navbarLinks = navbar.querySelectorAll('a');
    Array.from(navbarLinks).forEach((link) => {
      link.addEventListener('click', () => {
        toggleMenu();
      });
    });
  }
}

const docsPage = new DocsPage();
document.addEventListener('DOMContentLoaded', docsPage.init);
</file>

<file path="src/docs/mixins.scss">
@mixin css-prefix($property, $value) {
  -webkit-#{$property}: #{$value};
  -khtml-#{$property}: #{$value};
  -moz-#{$property}: #{$value};
  -ms-#{$property}: #{$value};
  -o-#{$property}: #{$value};
  #{$property}: #{$value};
}

@mixin animation($str) {
  @include css-prefix(animation, $str);
}

@mixin background-gradient($direction, $startColor, $startColorAmount, $endColor, $endColorAmount) {
  background: linear-gradient($direction, $startColor $startColorAmount, $endColor $endColorAmount);
  background-color: $startColor;
  filter: progid:dximagetransform.microsoft.gradient(startColorStr= '#{$startColor}', endColorStr='#{$endColor}');
}

@mixin hide-text {
  color: transparent;
  font: 0/0 a;
  text-shadow: none;
}

@mixin keyframes($animation-name) {
  @keyframes #{$animation-name} {
    @content;
  }
  @keyframes #{$animation-name} {
    @content;
  }
  @keyframes #{$animation-name} {
    @content;
  }
  @keyframes #{$animation-name} {
    @content;
  }
  @keyframes #{$animation-name} {
    @content;
  }
}

@mixin placeholder {
  &:placeholder {
    opacity: 1;
    @content;
  }

  &::placeholder {
    @content;
  }
}

@mixin pre-wrap {
  white-space: pre-wrap;
  white-space: -moz-pre-wrap;
  white-space: -pre-pre-wrap;
  white-space: -o-pre-wrap;
  word-wrap: break-word;
}

@mixin rotate($deg) {
  @include transform(rotate(#{$deg}deg));
}

@mixin text-overflow-ellipsis {
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  word-wrap: normal;
}

@mixin transform($transforms) {
  @include css-prefix(transform, $transforms);
}
</file>

<file path="src/docs/styles.scss">
@import 'mixins';
@import 'variables';

@include keyframes(spin) {
  100% {
    @include rotate(360);
  }
}
@include keyframes(slidein) {
  0% {
    transform: translateX(100%);
  }

  100% {
    transform: translateX(0%);
  }
}

body,
head,
html {
  height: 100%;
  width: 100%;
}

body {
  color: $colour-text1;
  display: flex;
  flex-direction: column;
  font-family: $font-stack-regular;
  overflow-x: hidden;

  &.noscroll {
    @media (max-width: $width-medium) {
      overflow: hidden;
    }
  }
}

h1 {
  @include hide-text;

  background: url('./images/logo.svg') no-repeat;
  height: 13rem;
  margin: auto;
  width: 10rem;
}

h2 {
  font-size: 2.5rem;
  font-weight: 700;
  margin: 0;
}

h3 {
  font-size: 2rem;
  font-weight: 700;
  margin: 0 0 2rem;
  text-align: center;
}

h4 {
  font-size: 1.4rem;
  font-weight: 700;
  margin: 0;
}

p {
  margin: 0 0 1rem;

  &:last-child {
    margin-bottom: 0;
  }
}

a {
  border-bottom: 1px dotted $colour-text1;
  color: $colour-text1;
  cursor: pointer;
  transition: color, ease-in, 0.2s;

  &:active,
  &:focus,
  &:hover,
  .active {
    border-bottom-color: $colour-link-highlight;
    color: $colour-link-highlight;
    outline: 0;
    text-decoration: none;
  }
}

nav,
header,
section {
  z-index: 1;
}

nav {
  &.navbar-custom {
    background: rgba($colour-text2, 0.9);

    &.open {
      @media (max-width: $width-medium) {
        @include animation(slidein 0.3s forwards);

        font-size: 1.5rem;
        height: 100vh;
        left: 0;
        padding: 8% 0 0 10%;
        position: fixed;
        top: 0;
        width: 100vw;
        z-index: 100;

        .nav,
        .navbar-collapse {
          display: block;

          &::before {
            content: ' ' !important;
            display: table !important;
          }
        }

        .navbar-nav > li > a {
          display: inline-block;
          line-height: 2rem;
        }
      }
    }

    #navbar {
      .navbar-nav {
        letter-spacing: 1px;

        li {
          a {
            border-bottom: 0 !important;
            color: $colour-text1;

            &:active,
            &:hover {
              color: $colour-link-highlight;
              outline: 0;
            }

            &:focus {
              @extend a;
            }

            &.active {
              background: transparent;
              color: $colour-link-highlight;

              &:active,
              &:focus,
              &:hover {
                @extend a;
              }
            }
          }
        }
      }

      @media (min-width: $width-medium) {
        justify-content: center;
      }
    }

    .navbar-collapse {
      border: 0;
      box-shadow: none;
    }

    @media (max-width: $width-medium) {
      margin-bottom: 0;
      min-height: auto;
      padding: 0;
    }
  }
}

pre {
  background: transparent;
  border: 0;
  padding: 0;
}

code {
  color: $colour-link-highlight !important;
  font-family: $font-stack-code;
}

header {
  padding: 5rem 0;

  & > .container > .row {
    @media (min-width: $width-large) {
      display: flex;

      .col-lg-7 {
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
    }
  }

  h2 {
    @media (max-width: $width-large) {
      text-align: center;
    }
  }

  .title {
    margin-top: 2.5rem;

    @media (min-width: $width-medium) {
      align-items: center;
      display: flex;
      margin-top: 0;
    }
  }
}

section {
  padding: 5rem 0;

  & > .container > .panel {
    a {
      border-bottom-color: $colour-text2;
      color: $colour-text2;

      &:active,
      &:focus,
      &:hover,
      .active {
        border-bottom-color: $colour-link-highlight;
        color: $colour-link-highlight;
      }
    }
  }

  &.dark {
    background-color: $colour-section1-bg;
    color: $colour-section1-text;

    a {
      border-bottom-color: $colour-section1-text;
      color: $colour-section1-text;

      &:active,
      &:focus,
      &:hover,
      .active {
        border-bottom-color: $colour-link-highlight;
        color: $colour-link-highlight;
      }
    }
  }

  .example {
    font-size: 0.9rem;
    margin-bottom: 3rem;

    p {
      font-style: italic;
      margin-bottom: 0.5rem;
    }

    pre {
      @media (min-width: $width-medium) {
        margin-left: 2rem;
      }
    }

    ul {
      list-style: none;
      padding: 0;

      @media (min-width: $width-medium) {
        margin-left: 2rem;
      }
    }
  }

  .header {
    display: flex;
    justify-content: space-between;

    .label {
      border-radius: 0.4rem;
      color: $colour-text1;
      font-size: 0.75rem;
      font-weight: bold;
      padding: 0.1rem 0.3rem;
      vertical-align: middle;

      &.label-info {
        background-color: $colour-bg2;
      }

      &.label-success {
        background-color: $colour-success;
      }

      &.label-warning {
        background-color: $colour-warning;
      }
    }

    @media (max-width: $width-small) {
      flex-direction: column;
    }
  }

  .panel {
    background-color: $colour-section2-bg;
    border-radius: 2rem;
    box-shadow: 0.6875rem 1.3125rem 4.125rem rgba(0, 0, 0, 0.25);
    color: $colour-section2-text;
    padding: 2rem;

    a {
      border-bottom-color: $colour-section2-text;
      color: $colour-section2-text;

      &:active,
      &:focus,
      &:hover,
      .active {
        border-bottom-color: $colour-link-highlight;
        color: $colour-link-highlight;
      }
    }
  }

  &#serviceinfo {
    margin-top: -5rem;
    padding-bottom: 2.5rem;
  }

  &#status {
    .serviceinfo {
      font-size: 1.2rem;
      margin-bottom: 1.5rem;
      width: 100%;

      &.offline {
        #servermessage,
        .version {
          display: none;
        }
      }

      #servermessage {
        font-style: italic;
        margin-top: 0.25rem;
        quotes: '\201c''\201d';
        text-align: center;

        & > p {
          display: inline-block;
        }
      }

      .status {
        display: flex;
        justify-content: space-evenly;

        & > span {
          display: block;
          line-height: 1.4rem;
          min-width: 8rem;
          text-align: center;
        }

        #location {
          display: none;
        }

        @media (max-width: 768px) {
          display: block;
          margin-bottom: 1rem;
        }
      }
    }
  }

  @media (max-width: $width-medium) {
    padding: 5rem 0;
  }
}

span {
  &.text-danger {
    color: $colour-danger !important;
  }

  &.text-success {
    color: $colour-success !important;
  }

  &.text-warning {
    color: $colour-warning !important;
  }
}

.background {
  @include background-gradient(20deg, $colour-bg1, 0, $colour-bg2, 100%);

  height: 100%;
  left: 0;
  position: fixed;
  top: 0;
  width: 100%;

  .background-img {
    background: url('./images/clouds.svg');
    background-repeat: repeat;
    background-size: $bg-width;
    display: block;
    height: $bg-height * 10;
    opacity: 0.2;
    position: absolute;
    top: -$bg-height;
    width: $bg-width * 10;
    z-index: 0;

    @media (max-width: $width-medium) {
      background-size: 40rem;
    }
  }
}

.container {
  @media (min-width: $width-xlarge) {
    max-width: 960px;
  }
}

.hamburger {
  border-bottom: 0.27rem solid $colour-text1;
  border-top: 0.27rem solid $colour-text1;
  display: inline-block;
  height: 1.34rem;
  opacity: 0.9;
  position: relative;
  top: -0.3rem;
  width: 1.75rem;

  &::before {
    border-top: 0.27rem solid $colour-text1;
    content: '';
    left: 0;
    position: absolute;
    top: 0.27rem;
    width: 100%;
  }
}

.nav-menu-button {
  background: rgba($colour-text2, 0.9);
  border: 0;
  border-radius: 5rem;
  color: $colour-text1;
  display: none;
  font-size: 1.75rem;
  height: 3rem;
  line-height: 3.7rem;
  outline: none;
  padding: 0;
  position: fixed;
  right: 6%;
  top: 4%;
  width: 3rem;
  z-index: 20;

  @media (max-width: $width-medium) {
    display: block;
  }
}
</file>

<file path="src/docs/variables.scss">
$font-stack-regular: 'Roboto Condensed', sans-serif;
$font-stack-code: consolas, menlo, 'Courier New', monospace;

$colour-bg1: #01ab8a;
$colour-bg2: #35c6e8;
$colour-text1: #edfeff;
$colour-text2: #083039;
$colour-link: #75959c;
$colour-link-highlight: $colour-bg2;
$colour-section1-bg: $colour-text2;
$colour-section1-text: $colour-text1;
$colour-section2-bg: $colour-text1;
$colour-section2-text: $colour-text2;
$colour-success: #30d278;
$colour-warning: #bdc71b;
$colour-danger: #ea3869;

$width-small: 576px;
$width-medium: 768px;
$width-large: 992px;
$width-xlarge: 1200px;

$bg-height: 32.142rem;
$bg-width: 53.571rem;
</file>

<file path="src/models/bookmarks.model.spec.ts">
import 'jest';
import moment from 'moment';
import * as Uuid from '../uuid';
import { BookmarksModel, IBookmarks } from './bookmarks.model';

describe('BookmarksModel', () => {
  const bookmarksDataTestVal =
    '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';
  const versionTestVal = '1.5.0';
  const lastAccessedTestVal = moment().add(1, 'days').startOf('day').toDate();
  const lastUpdatedTestVal = moment().add(2, 'days').startOf('day').toDate();

  it('bookmarksSchema: should create a default valid UUID', () => {
    const newBookmarks: IBookmarks = {
      bookmarks: bookmarksDataTestVal,
    };
    const bookmarksModel = new BookmarksModel(newBookmarks);
    const binary = Uuid.convertUuidStringToBinary(bookmarksModel._id);
    expect(bookmarksModel.id).not.toBeNull();
    expect(binary.buffer.length).toBe(16);
    expect(binary.sub_type).toBe(4);
  });

  it('bookmarksSchema: should convert string uuid value to binary when setting id', () => {
    const newBookmarks: IBookmarks = {
      bookmarks: bookmarksDataTestVal,
    };
    const bookmarksModel = new BookmarksModel(newBookmarks);
    const convertUuidStringToBinaryMock = jest.spyOn(Uuid, 'convertUuidStringToBinary').mockImplementation();
    bookmarksModel._id = '2b7b65fb-62bc-4162-8ec5-0008183c69b0';
    expect(convertUuidStringToBinaryMock).toBeCalled();
  });

  it('bookmarksSchema: should default lastAccessed value to now', () => {
    const newBookmarks: IBookmarks = {
      bookmarks: bookmarksDataTestVal,
    };
    const bookmarksModel = new BookmarksModel(newBookmarks);
    expect(bookmarksModel.lastAccessed).not.toBeNull();
    expect(bookmarksModel.lastAccessed.getTime()).toBeCloseTo(new Date().getTime(), -4);
  });

  it('bookmarksSchema: should default lastUpdated value to now', () => {
    const newBookmarks: IBookmarks = {
      bookmarks: bookmarksDataTestVal,
    };
    const bookmarksModel = new BookmarksModel(newBookmarks);
    expect(bookmarksModel.lastUpdated).not.toBeNull();
    expect(bookmarksModel.lastUpdated.getTime()).toBeCloseTo(new Date().getTime(), -4);
  });

  it('bookmarksSchema: should set bookmarks to provided value', () => {
    const newBookmarks: IBookmarks = {
      bookmarks: bookmarksDataTestVal,
    };
    const bookmarksModel = new BookmarksModel(newBookmarks);
    expect(bookmarksModel.bookmarks).toStrictEqual(bookmarksDataTestVal);
  });

  it('bookmarksSchema: should set lastAccessed to provided value', () => {
    const newBookmarks: IBookmarks = {
      lastAccessed: lastAccessedTestVal,
    };
    const bookmarksModel = new BookmarksModel(newBookmarks);
    expect(bookmarksModel.lastAccessed).toStrictEqual(lastAccessedTestVal);
  });

  it('bookmarksSchema: should set lastUpdated to provided value', () => {
    const newBookmarks: IBookmarks = {
      lastUpdated: lastUpdatedTestVal,
    };
    const bookmarksModel = new BookmarksModel(newBookmarks);
    expect(bookmarksModel.lastUpdated).toStrictEqual(lastUpdatedTestVal);
  });

  it('bookmarksSchema: should set version to provided value', () => {
    const newBookmarks: IBookmarks = {
      version: versionTestVal,
    };
    const bookmarksModel = new BookmarksModel(newBookmarks);
    expect(bookmarksModel.version).toStrictEqual(versionTestVal);
  });
});
</file>

<file path="src/models/bookmarks.model.ts">
import { Binary } from 'mongodb';
import mongoose from 'mongoose';
import { convertBytesToUuidString, convertUuidStringToBinary, generateRandomUuid } from '../uuid';

// Interface for bookmarks model
export interface IBookmarks {
  _id?: any;
  bookmarks?: string;
  lastAccessed?: Date;
  lastUpdated?: Date;
  version?: string;
}

// Interface for bookmarks mongoose model
export interface IBookmarksModel extends IBookmarks, mongoose.Document {
  _id: any;
}

// Create bookmarks schema to store bookmarks sync data
// Store IDs as binary uuid v4 and disable default id properties
// No concurrent updates so disable version keys
const bookmarksSchema = new mongoose.Schema(
  {
    _id: {
      type: mongoose.Schema.Types.Buffer,
      get: convertBytesToUuidString,
      set: (idValue: string | Binary) => {
        if (idValue instanceof Binary) {
          return idValue;
        }

        return convertUuidStringToBinary(idValue as string);
      },
      default: () => generateRandomUuid(),
    },
    bookmarks: String,
    lastAccessed: {
      default: Date,
      type: Date,
    },
    lastUpdated: {
      default: Date,
      type: Date,
    },
    version: String,
  },
  {
    _id: false,
    id: false,
    versionKey: false,
  }
);

export const BookmarksModel = mongoose.model<IBookmarksModel>('Bookmark', bookmarksSchema, 'bookmarks');
</file>

<file path="src/models/newSyncLogs.model.spec.ts">
import 'jest';
import moment from 'moment';
import { convertUuidStringToBinary } from '../uuid';
import { NewSyncLogsModel } from './newSyncLogs.model';

describe('NewSyncLogsModel', () => {
  it('newSyncLogsSchema: should create a default valid UUID', () => {
    const newSyncLogsModel = new NewSyncLogsModel();
    expect(newSyncLogsModel.id).not.toBeNull();
    expect(() => {
      convertUuidStringToBinary(newSyncLogsModel.id);
    }).not.toThrowError();
  });

  it('newSyncLogsSchema: should set expiresAt value by default to the start of the following day', () => {
    const newSyncLogsModel = new NewSyncLogsModel();
    expect(newSyncLogsModel.expiresAt).toStrictEqual(moment().add(1, 'days').startOf('day').toDate());
  });

  it('newSyncLogsSchema: should set syncCreated value by default to the current date', () => {
    const newSyncLogsModel = new NewSyncLogsModel();
    expect(newSyncLogsModel.syncCreated.getTime()).toBeCloseTo(moment().toDate().getTime(), -2);
  });
});
</file>

<file path="src/models/newSyncLogs.model.ts">
import moment from 'moment';
import mongoose from 'mongoose';
import * as uuid from 'uuid';

// Interface for new sync log model
export interface INewSyncLog {
  expiresAt?: Date;
  ipAddress?: string;
  syncCreated?: Date;
}

export interface INewSyncLogsModel extends INewSyncLog, mongoose.Document {}

// Create new sync logs schema to store ip address and created date
// No concurrent updates so disable version keys
const newSyncLogsSchema = new mongoose.Schema(
  {
    _id: { type: String, default: uuid.v4 },
    expiresAt: {
      default: () => moment().add(1, 'days').startOf('day').toDate(),
      type: Date,
    },
    ipAddress: String,
    syncCreated: {
      default: () => new Date(),
      type: Date,
    },
  },
  {
    versionKey: false,
  }
);

export const NewSyncLogsModel = mongoose.model<INewSyncLogsModel>('NewSyncLog', newSyncLogsSchema, 'newsynclogs');
</file>

<file path="src/routers/api.router.spec.ts">
import 'jest';
import { Verb } from '../common/enums';
import { NotImplementedException, UnsupportedVersionException } from '../exception';
import { ApiRouter } from './api.router';

jest.mock('express', () => {
  return {
    Router: () => {
      return {
        get: jest.fn(),
      };
    },
  };
});
jest.mock('express-routes-versioning', () => {
  return () => {
    return () => {};
  };
});

describe('ApiRouter', () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('ApiRouter: constructor should initialise routes', async () => {
    const initRoutesMock = jest.spyOn(ApiRouter.prototype, 'initRoutes').mockImplementation();
    const router = new ApiRouter(null);
    expect(router).not.toBeNull();
    expect(initRoutesMock).toBeCalled();
  });

  it('ApiRouter: initRoutes should throw NotImplementedException', async () => {
    expect(() => {
      const apiRouter = new ApiRouter(null);
    }).toThrow(NotImplementedException);
  });

  it('ApiRouter: unsupportedVersion should throw UnsupportedVersionException', async () => {
    const initRoutesMock = jest.spyOn(ApiRouter.prototype, 'initRoutes').mockImplementation();
    const router = new ApiRouter(null);
    expect(() => {
      router.unsupportedVersion();
    }).toThrow(UnsupportedVersionException);
  });

  it('ApiRouter: should create a route with the provided verb, path and version mappings', async () => {
    jest.spyOn(ApiRouter.prototype, 'initRoutes').mockImplementation();
    const router = new ApiRouter(null);
    router.createRoute(Verb.get, '/', { '^1.0.0': () => {} });
    expect(router._router[Verb.get]).toStrictEqual(expect.any(Function));
  });
});
</file>

<file path="src/routers/api.router.ts">
import { autobind } from 'core-decorators';
import { Application, Router } from 'express';
import { Verb } from '../common/enums';
import { NotImplementedException, UnsupportedVersionException } from '../exception';

// Interface for router implementations
export interface IApiRouter {
  initRoutes(): void;
}

// Base class for router implementations
// Implements the routes that are served by the api
export class ApiRouter<T> implements IApiRouter {
  _router: Router;
  _routesVersioning = require('express-routes-versioning')();

  constructor(protected app: Application, protected service?: T) {
    // Configure routes
    this._router = Router();
    this.initRoutes();
  }

  // Initialises the routes for this router implementation
  initRoutes(): void {
    throw new NotImplementedException();
  }

  // Adds a new route to this router implementation
  @autobind
  createRoute(verb: Verb, path: string, versionMappings: any): void {
    this._router[verb](path, this._routesVersioning(versionMappings, this.unsupportedVersion));
  }

  // Throws an error for when a requested api version is not supported
  unsupportedVersion(): void {
    throw new UnsupportedVersionException();
  }
}
</file>

<file path="src/routers/bookmarks.router.spec.ts">
import 'jest';
import { Request, Response } from 'express';
import { Verb } from '../common/enums';
import * as Config from '../config';
import { InvalidSyncIdException, RequiredDataNotFoundException } from '../exception';
import * as Uuid from '../uuid';
import { BookmarksRouter } from './bookmarks.router';

jest.mock('express-routes-versioning', () => {
  return () => {
    return () => {};
  };
});

describe('InfoRouter', () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('initRoutes: should configure app with base bookmarks route', async () => {
    const relativePathTest = '/';
    const configSettingsTest: Config.IConfigSettings = {
      server: {
        relativePath: relativePathTest,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const initRoutesSpy = jest.spyOn(BookmarksRouter.prototype, 'initRoutes');
    const useMock = jest.fn().mockImplementation();
    const app: any = {
      use: useMock,
    };
    jest.spyOn(BookmarksRouter.prototype, 'createRoute').mockImplementation();
    const bookmarksRouter = new BookmarksRouter(app);
    expect(initRoutesSpy).toHaveBeenCalled();
    expect(useMock).toHaveBeenCalledWith(`${relativePathTest}bookmarks`, expect.any(Function));
  });

  it('initRoutes: should create root bookmarks route', async () => {
    const initRoutesSpy = jest.spyOn(BookmarksRouter.prototype, 'initRoutes');
    const app: any = {
      use: jest.fn(),
    };
    const createRouteMock = jest.spyOn(BookmarksRouter.prototype, 'createRoute').mockImplementation();
    const bookmarksRouter = new BookmarksRouter(app);
    expect(initRoutesSpy).toHaveBeenCalled();
    expect(createRouteMock).toHaveBeenCalledWith(Verb.post, '/', {
      '~1.0.0': expect.any(Function),
      '^1.1.3': expect.any(Function),
    });
  });

  it('initRoutes: should create bookmarks id routes', async () => {
    const initRoutesSpy = jest.spyOn(BookmarksRouter.prototype, 'initRoutes');
    const app: any = {
      use: jest.fn(),
    };
    const createRouteMock = jest.spyOn(BookmarksRouter.prototype, 'createRoute').mockImplementation();
    const bookmarksRouter = new BookmarksRouter(app);
    expect(initRoutesSpy).toHaveBeenCalled();
    expect(createRouteMock).toHaveBeenCalledWith(Verb.get, '/:id', { '^1.0.0': expect.any(Function) });
    expect(createRouteMock).toHaveBeenCalledWith(Verb.put, '/:id', {
      '~1.0.0': expect.any(Function),
      '^1.1.3': expect.any(Function),
    });
  });

  it('initRoutes: should create bookmarks lastupdated route', async () => {
    const initRoutesSpy = jest.spyOn(BookmarksRouter.prototype, 'initRoutes');
    const app: any = {
      use: jest.fn(),
    };
    const createRouteMock = jest.spyOn(BookmarksRouter.prototype, 'createRoute').mockImplementation();
    const bookmarksRouter = new BookmarksRouter(app);
    expect(initRoutesSpy).toHaveBeenCalled();
    expect(createRouteMock).toHaveBeenCalledWith(Verb.get, '/:id/lastUpdated', { '^1.0.0': expect.any(Function) });
  });

  it('initRoutes: should create bookmarks version route', async () => {
    const initRoutesSpy = jest.spyOn(BookmarksRouter.prototype, 'initRoutes');
    const app: any = {
      use: jest.fn(),
    };
    const createRouteMock = jest.spyOn(BookmarksRouter.prototype, 'createRoute').mockImplementation();
    const bookmarksRouter = new BookmarksRouter(app);
    expect(initRoutesSpy).toHaveBeenCalled();
    expect(createRouteMock).toHaveBeenCalledWith(Verb.get, '/:id/version', { '^1.1.3': expect.any(Function) });
  });

  it('createBookmarks_v1: should call next with RequiredDataNotFoundException if bookmarks data missing from request', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    jest.spyOn(BookmarksRouter.prototype, 'getBookmarksData').mockReturnValue('');
    const router = new BookmarksRouter(null);
    const next = jest.fn();
    await router.createBookmarks_v1(null, null, next);
    expect(next).toHaveBeenCalledWith(expect.any(RequiredDataNotFoundException));
  });

  it('createBookmarks_v1: should call service createBookmarks_v1 function and return the result in the response as json', async () => {
    const bookmarksDataTest = 'bookmarksDataTest';
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const getBookmarksDataMock = jest
      .spyOn(BookmarksRouter.prototype, 'getBookmarksData')
      .mockReturnValue(bookmarksDataTest);
    const createBookmarksResult = 'test';
    const createBookmarksV1Mock = jest.fn().mockImplementation(() => {
      return Promise.resolve(createBookmarksResult);
    });
    const serviceTest = {
      createBookmarks_v1: createBookmarksV1Mock,
    };
    const router = new BookmarksRouter(null, serviceTest as any);
    const req: Partial<Request> = {};
    const jsonMock = jest.fn();
    const res: Partial<Response> = {
      json: jsonMock,
    };
    await router.createBookmarks_v1(req as Request, res as Response, null);
    expect(getBookmarksDataMock).toHaveBeenCalledWith(req);
    expect(createBookmarksV1Mock).toHaveBeenCalledWith(bookmarksDataTest, req);
    expect(jsonMock).toHaveBeenCalledWith(createBookmarksResult);
  });

  it('createBookmarks_v2: should call next with RequiredDataNotFoundException if version missing from post data', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const router = new BookmarksRouter(null);
    const req: Partial<Request> = {
      body: {
        version: '',
      },
    };
    const next = jest.fn();
    await router.createBookmarks_v2(req as Request, null, next);
    expect(next).toHaveBeenCalledWith(expect.any(RequiredDataNotFoundException));
  });

  it('createBookmarks_v2: should call service createBookmarks_v2 function and return the result in the response as json', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const createBookmarksResult = 'test';
    const createBookmarksV2Mock = jest.fn().mockImplementation(() => {
      return Promise.resolve(createBookmarksResult);
    });
    const serviceTest = {
      createBookmarks_v2: createBookmarksV2Mock,
    };
    const router = new BookmarksRouter(null, serviceTest as any);
    const versionTest = '1.0.0';
    const req: Partial<Request> = {
      body: {
        version: versionTest,
      },
    };
    const jsonMock = jest.fn();
    const res: Partial<Response> = {
      json: jsonMock,
    };
    await router.createBookmarks_v2(req as Request, res as Response, null);
    expect(createBookmarksV2Mock).toHaveBeenCalledWith(versionTest, req);
    expect(jsonMock).toHaveBeenCalledWith(createBookmarksResult);
  });

  it('getBookmarks: should call next with error if an error is encountered', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const errorTest = new Error();
    jest.spyOn(BookmarksRouter.prototype, 'getSyncId').mockImplementation((): any => {
      throw errorTest;
    });
    const router = new BookmarksRouter(null);
    const next = jest.fn();
    await router.getBookmarks(null, null, next);
    expect(next).toHaveBeenCalledWith(errorTest);
  });

  it('getBookmarks: should call service getBookmarks function and return the result in the response as json', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const getSyncIdResult = 'syncIdTest';
    const getSyncIdMock = jest.spyOn(BookmarksRouter.prototype, 'getSyncId').mockImplementation((): any => {
      return getSyncIdResult;
    });
    const getBookmarksResult = 'bookmarksTest';
    const getBookmarksMock = jest.fn().mockImplementation(() => {
      return Promise.resolve(getBookmarksResult);
    });
    const serviceTest = {
      getBookmarks: getBookmarksMock,
    };
    const router = new BookmarksRouter(null, serviceTest as any);
    const req: Partial<Request> = {};
    const jsonMock = jest.fn();
    const res: Partial<Response> = {
      json: jsonMock,
    };
    await router.getBookmarks(req as Request, res as Response, null);
    expect(getSyncIdMock).toHaveBeenCalledWith(req);
    expect(getBookmarksMock).toHaveBeenCalledWith(getSyncIdResult, req);
    expect(jsonMock).toHaveBeenCalledWith(getBookmarksResult);
  });

  it('getBookmarksData: should return bookmarks value from post body', async () => {
    const bookmarksDataTest = 'bookmarksDataTest';
    const req: Partial<Request> = {
      body: {
        bookmarks: bookmarksDataTest,
      },
    };
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const router = new BookmarksRouter(null);
    const result = router.getBookmarksData(req as Request);
    expect(result).toStrictEqual(bookmarksDataTest);
  });

  it('getBookmarksData: should return an empty string if bookmarks value missing from post body', async () => {
    const req: Partial<Request> = {
      body: {},
    };
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const router = new BookmarksRouter(null);
    const result = router.getBookmarksData(req as Request);
    expect(result).toStrictEqual('');
  });

  it('getLastUpdated: should call next with error if an error is encountered', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const errorTest = new Error();
    jest.spyOn(BookmarksRouter.prototype, 'getSyncId').mockImplementation((): any => {
      throw errorTest;
    });
    const router = new BookmarksRouter(null);
    const next = jest.fn();
    await router.getLastUpdated(null, null, next);
    expect(next).toHaveBeenCalledWith(errorTest);
  });

  it('getLastUpdated: should call service getLastUpdated function and return the result in the response as json', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const getSyncIdResult = 'syncIdTest';
    const getSyncIdMock = jest.spyOn(BookmarksRouter.prototype, 'getSyncId').mockImplementation((): any => {
      return getSyncIdResult;
    });
    const getLastUpdatedResult = 'getLastUpdatedResult';
    const getLastUpdatedMock = jest.fn().mockImplementation(() => {
      return Promise.resolve(getLastUpdatedResult);
    });
    const serviceTest = {
      getLastUpdated: getLastUpdatedMock,
    };
    const router = new BookmarksRouter(null, serviceTest as any);
    const req: Partial<Request> = {};
    const jsonMock = jest.fn();
    const res: Partial<Response> = {
      json: jsonMock,
    };
    await router.getLastUpdated(req as Request, res as Response, null);
    expect(getSyncIdMock).toHaveBeenCalledWith(req);
    expect(getLastUpdatedMock).toHaveBeenCalledWith(getSyncIdResult, req);
    expect(jsonMock).toHaveBeenCalledWith(getLastUpdatedResult);
  });

  it('getSyncId: should throw an error if invalid id provided in request params', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const req: Partial<Request> = {
      params: {},
    };
    const error = new InvalidSyncIdException();
    jest.spyOn(Uuid, 'convertUuidStringToBinary').mockImplementation((): any => {
      throw error;
    });
    const router = new BookmarksRouter(null);
    expect(() => {
      router.getSyncId(req as Request);
    }).toThrow(error);
  });

  it('getSyncId: should return id provided in request params', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const idTest = 'idTest';
    const req: Partial<Request> = {
      params: {
        id: idTest,
      },
    };
    const convertUuidStringToBinaryMock = jest.spyOn(Uuid, 'convertUuidStringToBinary').mockImplementation();
    const router = new BookmarksRouter(null);
    const result = router.getSyncId(req as Request);
    expect(convertUuidStringToBinaryMock).toHaveBeenCalledWith(idTest);
    expect(result).toStrictEqual(idTest);
  });

  it('getVersion: should call next with error if an error is encountered', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const errorTest = new Error();
    jest.spyOn(BookmarksRouter.prototype, 'getSyncId').mockImplementation((): any => {
      throw errorTest;
    });
    const router = new BookmarksRouter(null);
    const next = jest.fn();
    await router.getVersion(null, null, next);
    expect(next).toHaveBeenCalledWith(errorTest);
  });

  it('getVersion: should call service getVersion function and return the result in the response as json', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const getSyncIdResult = 'syncIdTest';
    const getSyncIdMock = jest.spyOn(BookmarksRouter.prototype, 'getSyncId').mockImplementation((): any => {
      return getSyncIdResult;
    });
    const getVersionResult = '1.0.0';
    const getVersionMock = jest.fn().mockImplementation(() => {
      return Promise.resolve(getVersionResult);
    });
    const serviceTest = {
      getVersion: getVersionMock,
    };
    const router = new BookmarksRouter(null, serviceTest as any);
    const req: Partial<Request> = {};
    const jsonMock = jest.fn();
    const res: Partial<Response> = {
      json: jsonMock,
    };
    await router.getVersion(req as Request, res as Response, null);
    expect(getSyncIdMock).toHaveBeenCalledWith(req);
    expect(getVersionMock).toHaveBeenCalledWith(getSyncIdResult, req);
    expect(jsonMock).toHaveBeenCalledWith(getVersionResult);
  });

  it('updateBookmarks_v1: should call next with RequiredDataNotFoundException if bookmarks data missing from request', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    jest.spyOn(BookmarksRouter.prototype, 'getSyncId').mockImplementation();
    jest.spyOn(BookmarksRouter.prototype, 'getBookmarksData').mockReturnValue('');
    const router = new BookmarksRouter(null);
    const next = jest.fn();
    await router.updateBookmarks_v1(null, null, next);
    expect(next).toHaveBeenCalledWith(expect.any(RequiredDataNotFoundException));
  });

  it('updateBookmarks_v1: should call service updateBookmarks_v1 function and return the result in the response as json', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const getSyncIdResult = 'syncIdTest';
    const getSyncIdMock = jest.spyOn(BookmarksRouter.prototype, 'getSyncId').mockImplementation((): any => {
      return getSyncIdResult;
    });
    const bookmarksDataTest = 'bookmarksDataTest';
    const getBookmarksDataMock = jest
      .spyOn(BookmarksRouter.prototype, 'getBookmarksData')
      .mockReturnValue(bookmarksDataTest);
    const updateBookmarksResult = 'test';
    const updateBookmarksV1Mock = jest.fn().mockImplementation(() => {
      return Promise.resolve(updateBookmarksResult);
    });
    const serviceTest = {
      updateBookmarks_v1: updateBookmarksV1Mock,
    };
    const router = new BookmarksRouter(null, serviceTest as any);
    const req: Partial<Request> = {};
    const jsonMock = jest.fn();
    const res: Partial<Response> = {
      json: jsonMock,
    };
    await router.updateBookmarks_v1(req as Request, res as Response, null);
    expect(getSyncIdMock).toHaveBeenCalledWith(req);
    expect(getBookmarksDataMock).toHaveBeenCalledWith(req);
    expect(updateBookmarksV1Mock).toHaveBeenCalledWith(getSyncIdResult, bookmarksDataTest, req);
    expect(jsonMock).toHaveBeenCalledWith(updateBookmarksResult);
  });

  it('updateBookmarks_v2: should call next with RequiredDataNotFoundException if bookmarks data missing from request', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    jest.spyOn(BookmarksRouter.prototype, 'getSyncId').mockImplementation();
    jest.spyOn(BookmarksRouter.prototype, 'getBookmarksData').mockReturnValue('');
    const router = new BookmarksRouter(null);
    const next = jest.fn();
    await router.updateBookmarks_v2(null, null, next);
    expect(next).toHaveBeenCalledWith(expect.any(RequiredDataNotFoundException));
  });

  it('updateBookmarks_v2: should call service updateBookmarks_v1 function and return the result in the response as json', async () => {
    jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const getSyncIdResult = 'syncIdTest';
    const getSyncIdMock = jest.spyOn(BookmarksRouter.prototype, 'getSyncId').mockImplementation((): any => {
      return getSyncIdResult;
    });
    const bookmarksDataTest = 'bookmarksDataTest';
    const getBookmarksDataMock = jest
      .spyOn(BookmarksRouter.prototype, 'getBookmarksData')
      .mockReturnValue(bookmarksDataTest);
    const updateBookmarksResult = 'test';
    const updateBookmarksV2Mock = jest.fn().mockImplementation(() => {
      return Promise.resolve(updateBookmarksResult);
    });
    const serviceTest = {
      updateBookmarks_v2: updateBookmarksV2Mock,
    };
    const router = new BookmarksRouter(null, serviceTest as any);
    const lastUpdatedTest = 'lastUpdatedTest';
    const versionTest = 'versionTest';
    const req: Partial<Request> = {
      body: {
        lastUpdated: lastUpdatedTest,
        version: versionTest,
      },
    };
    const jsonMock = jest.fn();
    const res: Partial<Response> = {
      json: jsonMock,
    };
    await router.updateBookmarks_v2(req as Request, res as Response, null);
    expect(getSyncIdMock).toHaveBeenCalledWith(req);
    expect(getBookmarksDataMock).toHaveBeenCalledWith(req);
    expect(updateBookmarksV2Mock).toHaveBeenCalledWith(
      getSyncIdResult,
      bookmarksDataTest,
      lastUpdatedTest,
      versionTest,
      req
    );
    expect(jsonMock).toHaveBeenCalledWith(updateBookmarksResult);
  });
});
</file>

<file path="src/routers/bookmarks.router.ts">
import { autobind } from 'core-decorators';
import { NextFunction, Request, Response } from 'express';
import { Verb } from '../common/enums';
import * as Config from '../config';
import { RequiredDataNotFoundException } from '../exception';
import { BookmarksService } from '../services/bookmarks.service';
import { convertUuidStringToBinary } from '../uuid';
import { ApiRouter, IApiRouter } from './api.router';

// Implementation of routes for bookmarks operations
export class BookmarksRouter extends ApiRouter<BookmarksService> implements IApiRouter {
  // Initialises the routes for this router implementation
  initRoutes(): void {
    this.app.use(`${Config.get().server.relativePath}bookmarks`, this._router);
    this.createRoute(Verb.post, '/', {
      '~1.0.0': this.createBookmarks_v1,
      // tslint:disable-next-line:object-literal-sort-keys
      '^1.1.3': this.createBookmarks_v2,
    });
    this.createRoute(Verb.get, '/:id', { '^1.0.0': this.getBookmarks });
    this.createRoute(Verb.put, '/:id', {
      '~1.0.0': this.updateBookmarks_v1,
      // tslint:disable-next-line:object-literal-sort-keys
      '^1.1.3': this.updateBookmarks_v2,
    });
    this.createRoute(Verb.get, '/:id/lastUpdated', { '^1.0.0': this.getLastUpdated });
    this.createRoute(Verb.get, '/:id/version', { '^1.1.3': this.getVersion });
  }

  // Creates a new bookmarks sync and returns new sync ID
  @autobind
  async createBookmarks_v1(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      // Get posted bookmarks data
      const bookmarksData = this.getBookmarksData(req);
      if (bookmarksData === '') {
        throw new RequiredDataNotFoundException();
      }

      // Call service method to create new bookmarks sync and return response as json
      const newSync = await this.service.createBookmarks_v1(bookmarksData, req);
      res.json(newSync);
    } catch (err) {
      next(err);
    }
  }

  // Creates an empty sync using sync version and returns new sync ID
  @autobind
  async createBookmarks_v2(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      // Get posted sync version
      const syncVersion = req.body.version;
      if (!syncVersion) {
        throw new RequiredDataNotFoundException();
      }

      // Call service method to create new sync and return response as json
      const newSync = await this.service.createBookmarks_v2(req.body.version, req);
      res.json(newSync);
    } catch (err) {
      next(err);
    }
  }

  // Retrieves an existing sync with a provided sync ID
  @autobind
  async getBookmarks(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      // Check sync id has been provided
      const id = this.getSyncId(req);

      // Call service method to retrieve bookmarks data and return response as json
      const bookmarks = await this.service.getBookmarks(id, req);
      res.json(bookmarks);
    } catch (err) {
      next(err);
    }
  }

  // Retrieves posted bookmarks data from request body
  getBookmarksData(req: Request): string {
    return req.body.bookmarks || '';
  }

  // Retrieves last updated date for a given sync ID
  @autobind
  async getLastUpdated(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      // Check sync id has been provided
      const id = this.getSyncId(req);

      // Call service method to get bookmarks last updated date and return response as json
      const lastUpdated = await this.service.getLastUpdated(id, req);
      res.json(lastUpdated);
    } catch (err) {
      next(err);
    }
  }

  // Retrieves the sync ID from the request query string parameters
  getSyncId(req: Request): string {
    // Check id is valid
    const id = req.params.id;
    convertUuidStringToBinary(id);
    return id;
  }

  // Retrieves sync version for a given sync ID
  @autobind
  async getVersion(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      // Check sync id has been provided
      const id = this.getSyncId(req);

      // Call service method to get sync version and return response as json
      const syncVersion = await this.service.getVersion(id, req);
      res.json(syncVersion);
    } catch (err) {
      next(err);
    }
  }

  // Updates bookmarks data for a given bookmarks sync ID
  @autobind
  async updateBookmarks_v1(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      // Check sync id has been provided
      const id = this.getSyncId(req);

      // Get posted bookmarks data
      const bookmarksData = this.getBookmarksData(req);
      if (bookmarksData === '') {
        throw new RequiredDataNotFoundException();
      }

      // Call service method to update bookmarks data and return response as json
      const bookmarksSync = await this.service.updateBookmarks_v1(id, bookmarksData, req);
      res.json(bookmarksSync);
    } catch (err) {
      next(err);
    }
  }

  // Updates bookmarks sync bookmarks data and sync version for a given bookmarks sync ID
  @autobind
  async updateBookmarks_v2(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      // Check sync id has been provided
      const id = this.getSyncId(req);

      // Get posted bookmarks data
      const bookmarksData = this.getBookmarksData(req);
      if (bookmarksData === '') {
        throw new RequiredDataNotFoundException();
      }

      // Call service method to update bookmarks data and return response as json
      const bookmarksSync = await this.service.updateBookmarks_v2(
        id,
        bookmarksData,
        req.body.lastUpdated,
        req.body.version,
        req
      );
      res.json(bookmarksSync);
    } catch (err) {
      next(err);
    }
  }
}
</file>

<file path="src/routers/docs.router.spec.ts">
import 'jest';
import express from 'express';
import path from 'path';
import * as Config from '../config';
import { DocsRouter, relativePathToDocs } from './docs.router';

jest.mock('express-routes-versioning');

describe('DocsRouter', () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('initRoutes: should provide app with docs route', async () => {
    const relativePathTest = '/';
    const configSettingsTest: Config.IConfigSettings = {
      server: {
        relativePath: relativePathTest,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const initRoutesSpy = jest.spyOn(DocsRouter.prototype, 'initRoutes');
    jest.spyOn(path, 'join').mockImplementation((...args): any => {
      return args[1];
    });
    let relativePath;
    const staticMock = jest.spyOn(express, 'static').mockImplementation((...args): any => {
      relativePath = args[0];
      return relativePath;
    });
    let routePath;
    let handler;
    const useMock = jest.fn().mockImplementation((...args) => {
      routePath = args[0];
      handler = args[1];
    });
    const app: any = {
      get: jest.fn(),
      use: useMock,
    };
    const router = new DocsRouter(app);
    expect(router).not.toBeNull();
    expect(initRoutesSpy).toBeCalled();
    expect(useMock).toBeCalled();
    expect(routePath).toStrictEqual(relativePathTest);
    expect(staticMock).toBeCalled();
    expect(relativePath).toStrictEqual(relativePathToDocs);
    expect(handler).toStrictEqual(relativePathToDocs);
  });
});
</file>

<file path="src/routers/docs.router.ts">
import express from 'express';
import path from 'path';
import * as Config from '../config';
import { ApiRouter, IApiRouter } from './api.router';

export const relativePathToDocs = '../docs';

// Implementation of routes for API documentation
export class DocsRouter extends ApiRouter<void> implements IApiRouter {
  // Initialises the routes for this router implementation
  initRoutes(): void {
    this.app.get('/favicon.ico', (req, res) => res.status(204));

    this.app.use(Config.get().server.relativePath, express.static(path.join(__dirname, relativePathToDocs)));
  }
}
</file>

<file path="src/routers/info.router.spec.ts">
import 'jest';
import { Request, Response } from 'express';
import { Verb } from '../common/enums';
import * as Config from '../config';
import { InfoRouter } from './info.router';

jest.mock('express-routes-versioning', () => {
  return () => {
    return () => {};
  };
});

describe('InfoRouter', () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('initRoutes: should configure app with base info route', async () => {
    const relativePathTest = '/';
    const configSettingsTest: Config.IConfigSettings = {
      server: {
        relativePath: relativePathTest,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const initRoutesSpy = jest.spyOn(InfoRouter.prototype, 'initRoutes');
    const useMock = jest.fn().mockImplementation();
    const app: any = {
      use: useMock,
    };
    jest.spyOn(InfoRouter.prototype, 'createRoute').mockImplementation();
    const infoRouter = new InfoRouter(app);
    expect(initRoutesSpy).toBeCalled();
    expect(useMock).toBeCalledWith(`${relativePathTest}info`, expect.any(Function));
  });

  it('initRoutes: should create root info route', async () => {
    const initRoutesSpy = jest.spyOn(InfoRouter.prototype, 'initRoutes');
    const app: any = {
      use: jest.fn(),
    };
    const createRouteMock = jest.spyOn(InfoRouter.prototype, 'createRoute').mockImplementation();
    const infoRouter = new InfoRouter(app);
    expect(initRoutesSpy).toBeCalled();
    expect(createRouteMock).toBeCalledWith(Verb.get, '/', { '^1.0.0': expect.any(Function) });
  });

  it('getInfo: should call service getInfo function and return the result in the response', async () => {
    jest.spyOn(InfoRouter.prototype, 'initRoutes').mockImplementation();
    const getInfoMockResult = 'test';
    const getInfoMock = jest.fn().mockImplementation(() => {
      return Promise.resolve(getInfoMockResult);
    });
    const serviceTest = {
      getInfo: getInfoMock,
    };
    const router = new InfoRouter(null, serviceTest as any);
    const req: Partial<Request> = {};
    const sendMock = jest.fn();
    const res: Partial<Response> = {
      send: sendMock,
    };
    const next = jest.fn();
    await router.getInfo(req as Request, res as Response, next);
    expect(getInfoMock).toBeCalledWith(req);
    expect(sendMock).toBeCalledWith(getInfoMockResult);
  });

  it('getInfo: should call next with error when error encountered', async () => {
    jest.spyOn(InfoRouter.prototype, 'initRoutes').mockImplementation();
    const errorTest = new Error();
    const getInfoMock = jest.fn().mockImplementation(() => {
      throw errorTest;
    });
    const serviceTest = {
      getInfo: getInfoMock,
    };
    const router = new InfoRouter(null, serviceTest as any);
    const req: Partial<Request> = {};
    const sendMock = jest.fn();
    const res: Partial<Response> = {
      send: sendMock,
    };
    const next = jest.fn();
    await router.getInfo(req as Request, res as Response, next);
    expect(next).toBeCalledWith(errorTest);
  });
});
</file>

<file path="src/routers/info.router.ts">
import { autobind } from 'core-decorators';
import { NextFunction, Request, Response } from 'express';
import { Verb } from '../common/enums';
import * as Config from '../config';
import { InfoService } from '../services/info.service';
import { ApiRouter, IApiRouter } from './api.router';

// Implementation of routes for service info operations
export class InfoRouter extends ApiRouter<InfoService> implements IApiRouter {
  // Initialises the routes for this router implementation
  initRoutes(): void {
    this.app.use(`${Config.get().server.relativePath}info`, this._router);
    this.createRoute(Verb.get, '/', { '^1.0.0': this.getInfo });
  }

  // Gets service info such as status, version, etc
  @autobind
  async getInfo(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      // Call service method to get service info and return response as json
      const serviceInfo = await this.service.getInfo(req);
      res.send(serviceInfo);
    } catch (err) {
      next(err);
    }
  }
}
</file>

<file path="src/services/api.service.spec.ts">
import 'jest';
import { ApiService } from './api.service';

describe('ApiService', () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('ApiService: constructor should initialise service and log', async () => {
    const logTest = {};
    const serviceTest = {};
    const apiService = new ApiService(serviceTest, logTest as any);
    expect(apiService).not.toBeNull();
    expect(apiService.service).toBe(serviceTest);
    expect(apiService.log).toBe(logTest);
  });
});
</file>

<file path="src/services/api.service.ts">
import { Request } from 'express';
import { LogLevel } from '../common/enums';

// Base class for data service implementations
// Implements the functionality executed when calling a route
export class ApiService<T> {
  log: (level: LogLevel, message: string, req?: Request, err?: Error) => void;
  service: T;

  constructor(service: T, log: (level: LogLevel, message: string, req?: Request, err?: Error) => void) {
    this.service = service;
    this.log = log;
  }
}
</file>

<file path="src/services/bookmarks.service.spec.ts">
import 'jest';
import { Request } from 'express';
import { LogLevel } from '../common/enums';
import * as Utils from '../common/utils';
import * as Config from '../config';
import {
  NewSyncsForbiddenException,
  NewSyncsLimitExceededException,
  SyncConflictException,
  SyncNotFoundException,
  UnspecifiedException,
} from '../exception';
import { BookmarksModel, IBookmarks } from '../models/bookmarks.model';
import { BookmarksService } from './bookmarks.service';
import { NewSyncLogsService } from './newSyncLogs.service';

jest.mock('../models/bookmarks.model');
jest.mock('./newSyncLogs.service');

describe('BookmarksService', () => {
  const bookmarksDataTestVal = `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`;
  const createdDateTestVal = new Date();
  const syncVersionTestVal = '1.1.3';
  let logMock: jest.Mock<any, any>;

  beforeEach(() => {
    logMock = jest.fn();
    jest.spyOn(Utils, 'checkServiceAvailability').mockImplementation();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('createBookmarks_v1: should return a valid create bookmarks response', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      dailyNewSyncsLimit: 0,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const idTest = 'idTest';
    const lastUpdatedTest = new Date();
    const dbOpResult: IBookmarks = {
      _id: idTest,
      lastUpdated: lastUpdatedTest,
    };
    BookmarksModel.prototype.save.mockResolvedValue(dbOpResult);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    const response = await bookmarksService.createBookmarks_v1(bookmarksDataTestVal, req as Request);
    expect(response.id).toBe(idTest);
    expect(response.lastUpdated).toBe(lastUpdatedTest);
  });

  it('createBookmarks_v1: should throw a NewSyncsForbiddenException if service is not accepting new syncs', async () => {
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(false);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.createBookmarks_v1(bookmarksDataTestVal, req as Request)).rejects.toThrow(
      NewSyncsForbiddenException
    );
  });

  it('createBookmarks_v1: should throw a NewSyncsLimitExceededException if daily new syncs limit has been hit', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      dailyNewSyncsLimit: 1,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(NewSyncLogsService.prototype, 'newSyncsLimitHit').mockResolvedValue(true);
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(newSyncLogsService, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.createBookmarks_v1(bookmarksDataTestVal, req as Request)).rejects.toThrow(
      NewSyncsLimitExceededException
    );
  });

  it('createBookmarks_v1: should add a new sync log if daily new syncs limit is enabled', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      dailyNewSyncsLimit: 1,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(NewSyncLogsService.prototype, 'newSyncsLimitHit').mockResolvedValue(false);
    const createLogMock = jest.spyOn(NewSyncLogsService.prototype, 'createLog').mockResolvedValue({});
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(newSyncLogsService, logMock);
    jest.spyOn(BookmarksModel.prototype, 'save').mockResolvedValue({});
    const req: Partial<Request> = {};
    await bookmarksService.createBookmarks_v1(bookmarksDataTestVal, req as Request);
    expect(createLogMock).toHaveBeenCalledWith(req);
  });

  it('createBookmarks_v1: should catch and log any error that is encountered before rethrowing', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      dailyNewSyncsLimit: 1,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(NewSyncLogsService.prototype, 'newSyncsLimitHit').mockResolvedValue(false);
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(newSyncLogsService, logMock);
    const errorTest = new Error();
    jest.spyOn(BookmarksModel.prototype, 'save').mockImplementation(() => {
      throw errorTest;
    });
    const req: Partial<Request> = {};
    await expect(bookmarksService.createBookmarks_v1(bookmarksDataTestVal, req as Request)).rejects.toThrow(errorTest);
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), req, errorTest);
  });

  it('createBookmarks_v2: should return a valid create bookmarks response', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      dailyNewSyncsLimit: 0,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(NewSyncLogsService.prototype, 'newSyncsLimitHit').mockResolvedValue(false);
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(newSyncLogsService, logMock);
    const idTest = 'idTest';
    const lastUpdatedTest = new Date();
    const versionTest = 'versionTest';
    const dbOpResult: IBookmarks = {
      _id: idTest,
      lastUpdated: lastUpdatedTest,
      version: versionTest,
    };
    jest.spyOn(BookmarksModel.prototype, 'save').mockResolvedValue(dbOpResult);
    const req: Partial<Request> = {};
    const response = await bookmarksService.createBookmarks_v2(syncVersionTestVal, req as Request);
    expect(response.id).toBe(idTest);
    expect(response.lastUpdated).toBe(lastUpdatedTest);
    expect(response.version).toBe(versionTest);
  });

  it('createBookmarks_v2: should throw a NewSyncsForbiddenException if service is not accepting new syncs', async () => {
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(false);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.createBookmarks_v2(syncVersionTestVal, req as Request)).rejects.toThrow(
      NewSyncsForbiddenException
    );
  });

  it('createBookmarks_v2: should throw a NewSyncsLimitExceededException if daily new syncs limit has been hit', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      dailyNewSyncsLimit: 1,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(NewSyncLogsService.prototype, 'newSyncsLimitHit').mockResolvedValue(true);
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(newSyncLogsService, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.createBookmarks_v2(syncVersionTestVal, req as Request)).rejects.toThrow(
      NewSyncsLimitExceededException
    );
  });

  it('createBookmarks_v2: should add a new sync log if daily new syncs limit is enabled', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      dailyNewSyncsLimit: 1,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(NewSyncLogsService.prototype, 'newSyncsLimitHit').mockResolvedValue(false);
    const createLogMock = jest.spyOn(NewSyncLogsService.prototype, 'createLog').mockResolvedValue({});
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(newSyncLogsService, logMock);
    jest.spyOn(BookmarksModel.prototype, 'save').mockResolvedValue({});
    const req: Partial<Request> = {};
    await bookmarksService.createBookmarks_v2(syncVersionTestVal, req as Request);
    expect(createLogMock).toHaveBeenCalledWith(req);
  });

  it('createBookmarks_v2: should catch and log any error that is encountered before rethrowing', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      dailyNewSyncsLimit: 1,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(NewSyncLogsService.prototype, 'newSyncsLimitHit').mockResolvedValue(false);
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(newSyncLogsService, logMock);
    const errorTest = new Error();
    jest.spyOn(BookmarksModel.prototype, 'save').mockImplementation(() => {
      throw errorTest;
    });
    const req: Partial<Request> = {};
    await expect(bookmarksService.createBookmarks_v2(syncVersionTestVal, req as Request)).rejects.toThrow(errorTest);
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), req, errorTest);
  });

  it('getBookmarks: should return bookmarks data', async () => {
    const dbOpResult: IBookmarks = {
      bookmarks: bookmarksDataTestVal,
      lastUpdated: createdDateTestVal,
      version: syncVersionTestVal,
    };
    const findOneAndUpdateMock = jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockReturnValue({
      exec: () => Promise.resolve(dbOpResult),
    } as any);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    const bookmarksSync = await bookmarksService.getBookmarks(null, req as Request);
    expect(findOneAndUpdateMock).toHaveBeenCalled();
    expect(bookmarksSync.bookmarks).toStrictEqual(bookmarksDataTestVal);
    expect(bookmarksSync.version).toStrictEqual(syncVersionTestVal);
    expect(bookmarksSync.lastUpdated).toStrictEqual(createdDateTestVal);
  });

  it('getBookmarks: should throw a SyncNotFoundException if db operation returns null', async () => {
    jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockReturnValue({
      exec: () => Promise.resolve(null),
    } as any);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.getBookmarks(null, req as Request)).rejects.toThrow(SyncNotFoundException);
  });

  it('getBookmarks: should log errors that are not SyncNotFoundException', async () => {
    const errorTest = new Error();
    jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockImplementation(() => {
      throw errorTest;
    });
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.getBookmarks(null, req as Request)).rejects.toThrow(errorTest);
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), req, errorTest);
  });

  it('getBookmarks: should not log errors that are SyncNotFoundException', async () => {
    const errorTest = new SyncNotFoundException();
    jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockImplementation(() => {
      throw errorTest;
    });
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.getBookmarks(null, req as Request)).rejects.toThrow(errorTest);
    expect(logMock).not.toHaveBeenCalled();
  });

  it('getLastUpdated: should return bookmarks last updated date', async () => {
    const dbOpResult: IBookmarks = {
      lastUpdated: createdDateTestVal,
    };
    const findOneAndUpdateMock = jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockReturnValue({
      exec: () => Promise.resolve(dbOpResult),
    } as any);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    const bookmarksSync = await bookmarksService.getLastUpdated(null, req as Request);
    expect(findOneAndUpdateMock).toHaveBeenCalled();
    expect(bookmarksSync.lastUpdated).toStrictEqual(createdDateTestVal);
  });

  it('getLastUpdated: should throw a SyncNotFoundException if db operation returns null', async () => {
    jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockReturnValue({
      exec: () => Promise.resolve(null),
    } as any);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.getLastUpdated(null, req as Request)).rejects.toThrow(SyncNotFoundException);
  });

  it('getLastUpdated: should log errors that are not SyncNotFoundException', async () => {
    const errorTest = new Error();
    jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockImplementation(() => {
      throw errorTest;
    });
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.getLastUpdated(null, req as Request)).rejects.toThrow(errorTest);
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), req, errorTest);
  });

  it('getLastUpdated: should not log errors that are SyncNotFoundException', async () => {
    const errorTest = new SyncNotFoundException();
    jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockImplementation(() => {
      throw errorTest;
    });
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.getLastUpdated(null, req as Request)).rejects.toThrow(errorTest);
    expect(logMock).not.toHaveBeenCalled();
  });

  it('getVersion: should return bookmarks sync version', async () => {
    const dbOpResult: IBookmarks = {
      version: syncVersionTestVal,
    };
    const findOneAndUpdateMock = jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockReturnValue({
      exec: () => Promise.resolve(dbOpResult),
    } as any);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    const bookmarksSync = await bookmarksService.getVersion(null, req as Request);
    expect(findOneAndUpdateMock).toHaveBeenCalled();
    expect(bookmarksSync.version).toStrictEqual(syncVersionTestVal);
  });

  it('getVersion: should throw a SyncNotFoundException db operation returns null', async () => {
    jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockReturnValue({
      exec: () => Promise.resolve(null),
    } as any);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.getVersion(null, req as Request)).rejects.toThrow(SyncNotFoundException);
  });

  it('getVersion: should log errors that are not SyncNotFoundException', async () => {
    const errorTest = new Error();
    jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockImplementation(() => {
      throw errorTest;
    });
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.getVersion(null, req as Request)).rejects.toThrow(errorTest);
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), req, errorTest);
  });

  it('getVersion: should not log errors that are SyncNotFoundException', async () => {
    const errorTest = new SyncNotFoundException();
    jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockImplementation(() => {
      throw errorTest;
    });
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.getVersion(null, req as Request)).rejects.toThrow(errorTest);
    expect(logMock).not.toHaveBeenCalled();
  });

  it('isAcceptingNewSyncs: should return false if service is not accepting new syncs', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      status: {
        allowNewSyncs: false,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const bookmarksService = new BookmarksService(null, logMock);
    const isAcceptingNewSyncs = await bookmarksService.isAcceptingNewSyncs();
    expect(isAcceptingNewSyncs).toBe(false);
  });

  it('isAcceptingNewSyncs: should return true if max syncs limit is disabled', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      maxSyncs: 0,
      status: {
        allowNewSyncs: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const bookmarksService = new BookmarksService(null, logMock);
    const isAcceptingNewSyncs = await bookmarksService.isAcceptingNewSyncs();
    expect(isAcceptingNewSyncs).toBe(true);
  });

  it('isAcceptingNewSyncs: should return true if total bookmarks syncs is less than max syncs limit', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      maxSyncs: 1,
      status: {
        allowNewSyncs: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(BookmarksService.prototype, 'getBookmarksCount').mockResolvedValue(0);
    const bookmarksService = new BookmarksService(null, logMock);
    const isAcceptingNewSyncs = await bookmarksService.isAcceptingNewSyncs();
    expect(isAcceptingNewSyncs).toBe(true);
  });

  it('isAcceptingNewSyncs: should return false if total bookmarks syncs is not less than max syncs limit', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      maxSyncs: 1,
      status: {
        allowNewSyncs: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(BookmarksService.prototype, 'getBookmarksCount').mockResolvedValue(1);
    const bookmarksService = new BookmarksService(null, logMock);
    const isAcceptingNewSyncs = await bookmarksService.isAcceptingNewSyncs();
    expect(isAcceptingNewSyncs).toBe(false);
  });

  it('updateBookmarks_v1: should return updated date in response when updated bookmarks', async () => {
    const dbOpResult: IBookmarks = {
      lastUpdated: createdDateTestVal,
    };
    const findOneAndUpdateMock = jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockReturnValue({
      exec: () => Promise.resolve(dbOpResult),
    } as any);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    const updatedBookmarksSync = await bookmarksService.updateBookmarks_v1(null, bookmarksDataTestVal, req as Request);
    expect(findOneAndUpdateMock).toHaveBeenCalled();
    expect(updatedBookmarksSync.lastUpdated).toStrictEqual(createdDateTestVal);
  });

  it('updateBookmarks_v1: should not return updated date in response if no bookmarks were updated', async () => {
    const findOneAndUpdateMock = jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockReturnValue({
      exec: () => Promise.resolve(null),
    } as any);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    const updatedBookmarksSync = await bookmarksService.updateBookmarks_v1(null, bookmarksDataTestVal, req as Request);
    expect(findOneAndUpdateMock).toHaveBeenCalled();
    expect(updatedBookmarksSync.lastUpdated).toBeUndefined();
  });

  it('updateBookmarks_v1: should catch and log errors that are encountered before rethrowing', async () => {
    const errorTest = new Error();
    jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockImplementation(() => {
      throw errorTest;
    });
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(bookmarksService.updateBookmarks_v1(null, bookmarksDataTestVal, req as Request)).rejects.toThrow(
      errorTest
    );
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), req, errorTest);
  });

  it('updateBookmarks_v2: should return updated date in response when updated bookmarks', async () => {
    const dbOpResult: IBookmarks = {
      lastUpdated: createdDateTestVal,
    };
    const findByIdMock = jest.spyOn(BookmarksModel, 'findById').mockReturnValue({
      exec: () => Promise.resolve(dbOpResult),
    } as any);
    const findOneAndUpdateMock = jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockReturnValue({
      exec: () => Promise.resolve(dbOpResult),
    } as any);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    const updatedBookmarksSync = await bookmarksService.updateBookmarks_v2(
      null,
      bookmarksDataTestVal,
      null,
      syncVersionTestVal,
      req as Request
    );
    expect(findByIdMock).toHaveBeenCalled();
    expect(findOneAndUpdateMock).toHaveBeenCalled();
    expect(updatedBookmarksSync.lastUpdated).toStrictEqual(createdDateTestVal);
  });

  it('updateBookmarks_v2: should return updated date in response when updated bookmarks', async () => {
    const dbOpResult: IBookmarks = {
      lastUpdated: createdDateTestVal,
    };
    jest.spyOn(BookmarksModel, 'findById').mockReturnValue({
      exec: () => Promise.resolve(dbOpResult),
    } as any);
    let updatePayload: IBookmarks;
    jest.spyOn(BookmarksModel, 'findOneAndUpdate').mockImplementation((...args): any => {
      updatePayload = args[1];
      return {
        exec: () => Promise.resolve(dbOpResult),
      };
    });
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await bookmarksService.updateBookmarks_v2(null, bookmarksDataTestVal, null, null, req as Request);
    expect(Object.keys(updatePayload)).not.toContain('version');
  });

  it('updateBookmarks_v2: should throw a SyncNotFoundException if no existing bookmarks found', async () => {
    const findByIdMock = jest.spyOn(BookmarksModel, 'findById').mockReturnValue({
      exec: () => Promise.resolve(null),
    } as any);
    const req: Partial<Request> = {};
    const bookmarksService = new BookmarksService(null, logMock);
    await expect(
      bookmarksService.updateBookmarks_v2(null, bookmarksDataTestVal, null, syncVersionTestVal, req as Request)
    ).rejects.toThrow(SyncNotFoundException);
    expect(findByIdMock).toHaveBeenCalled();
  });

  it('updateBookmarks_v2: should throw a SyncConflictException if supplied last updated value does not match existing bookmarks', async () => {
    const dbOpResult: IBookmarks = {
      lastUpdated: createdDateTestVal,
    };
    const findByIdMock = jest.spyOn(BookmarksModel, 'findById').mockReturnValue({
      exec: () => Promise.resolve(dbOpResult),
    } as any);
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(
      bookmarksService.updateBookmarks_v2(
        null,
        bookmarksDataTestVal,
        new Date().toISOString(),
        syncVersionTestVal,
        req as Request
      )
    ).rejects.toThrow(SyncConflictException);
    expect(findByIdMock).toHaveBeenCalled();
  });

  it('updateBookmarks_v2: should log errors that are not SyncNotFoundException', async () => {
    const errorTest = new Error();
    jest.spyOn(BookmarksModel, 'findById').mockImplementation(() => {
      throw errorTest;
    });
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(
      bookmarksService.updateBookmarks_v2(
        null,
        bookmarksDataTestVal,
        new Date().toISOString(),
        syncVersionTestVal,
        req as Request
      )
    ).rejects.toThrow(errorTest);
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), req, errorTest);
  });

  it('updateBookmarks_v2: should not log errors that are SyncNotFoundException', async () => {
    const errorTest = new SyncNotFoundException();
    jest.spyOn(BookmarksModel, 'findById').mockImplementation(() => {
      throw errorTest;
    });
    const bookmarksService = new BookmarksService(null, logMock);
    const req: Partial<Request> = {};
    await expect(
      bookmarksService.updateBookmarks_v2(
        null,
        bookmarksDataTestVal,
        new Date().toISOString(),
        syncVersionTestVal,
        req as Request
      )
    ).rejects.toThrow(errorTest);
    expect(logMock).not.toHaveBeenCalled();
  });

  it('getBookmarksCount: should return bookmarks count', async () => {
    const countTest = 1;
    jest.spyOn(BookmarksModel, 'estimatedDocumentCount').mockReturnValue({
      exec: () => Promise.resolve(countTest),
    } as any);
    const bookmarksService = new BookmarksService(null, logMock);
    const bookmarksCount = await bookmarksService.getBookmarksCount();
    expect(bookmarksCount).toStrictEqual(countTest);
  });

  it('getBookmarksCount: should log errors encountered when running database operation', async () => {
    const errorTest = new Error();
    jest.spyOn(BookmarksModel, 'estimatedDocumentCount').mockImplementation(() => {
      throw errorTest;
    });
    const bookmarksService = new BookmarksService(null, logMock);
    await expect(bookmarksService.getBookmarksCount()).rejects.toThrow(errorTest);
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), null, errorTest);
  });

  it('getBookmarksCount: should log and throw an UnspecifiedException if bookmark count is less than zero', async () => {
    jest.spyOn(BookmarksModel, 'estimatedDocumentCount').mockReturnValue({
      exec: () => Promise.resolve(-1),
    } as any);
    const bookmarksService = new BookmarksService(null, logMock);
    await expect(bookmarksService.getBookmarksCount()).rejects.toThrow(UnspecifiedException);
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), null, expect.any(UnspecifiedException));
  });
});
</file>

<file path="src/services/bookmarks.service.ts">
import { Request } from 'express';
import { LogLevel } from '../common/enums';
import { checkServiceAvailability } from '../common/utils';
import * as Config from '../config';
import {
  NewSyncsForbiddenException,
  NewSyncsLimitExceededException,
  SyncConflictException,
  SyncNotFoundException,
  UnspecifiedException,
} from '../exception';
import { BookmarksModel, IBookmarks } from '../models/bookmarks.model';
import { ApiService } from './api.service';
import { NewSyncLogsService } from './newSyncLogs.service';

// Interface for create bookmarks operation response object
export interface ICreateBookmarksResponse {
  version?: string;
  id?: string;
  lastUpdated?: Date;
}

// Interface for get bookmarks operation response object
export interface IGetBookmarksResponse {
  bookmarks?: string;
  version?: string;
  lastUpdated?: Date;
}

// Interface for get bookmarks last updated date operation response object
export interface IGetLastUpdatedResponse {
  lastUpdated?: Date;
}

// Interface for get sync version operation response object
export interface IGetVersionResponse {
  version?: string;
}

// Interface for update bookmarks operation response object
export interface IUpdateBookmarksResponse {
  lastUpdated?: Date;
}

// Implementation of data service for bookmarks operations
export class BookmarksService extends ApiService<NewSyncLogsService> {
  // Creates a new bookmarks sync with the supplied bookmarks data
  async createBookmarks_v1(bookmarksData: string, req: Request): Promise<ICreateBookmarksResponse> {
    // Before proceeding, check service is available
    checkServiceAvailability();

    // Check service is accepting new syncs
    const isAcceptingNewSyncs = await this.isAcceptingNewSyncs();
    if (!isAcceptingNewSyncs) {
      throw new NewSyncsForbiddenException();
    }

    // Check if daily new syncs limit has been hit if config value enabled
    if (Config.get().dailyNewSyncsLimit > 0) {
      const newSyncsLimitHit = await this.service.newSyncsLimitHit(req);
      if (newSyncsLimitHit) {
        throw new NewSyncsLimitExceededException();
      }
    }

    try {
      // Create new bookmarks payload
      const newBookmarks: IBookmarks = {
        bookmarks: bookmarksData,
      };
      const bookmarksModel = new BookmarksModel(newBookmarks);

      // Commit the bookmarks payload to the db
      const savedBookmarks = await bookmarksModel.save();

      // Add to logs
      if (Config.get().dailyNewSyncsLimit > 0) {
        await this.service.createLog(req);
      }
      this.log(LogLevel.Info, 'New bookmarks sync created', req);

      // Return the response data
      const returnObj: ICreateBookmarksResponse = {
        id: savedBookmarks._id,
        lastUpdated: savedBookmarks.lastUpdated,
      };
      return returnObj;
    } catch (err) {
      this.log(LogLevel.Error, 'Exception occurred in BookmarksService.createBookmarks', req, err);
      throw err;
    }
  }

  // Creates an empty sync with the supplied version info
  async createBookmarks_v2(syncVersion: string, req: Request): Promise<ICreateBookmarksResponse> {
    // Before proceeding, check service is available
    checkServiceAvailability();

    // Check service is accepting new syncs
    const isAcceptingNewSyncs = await this.isAcceptingNewSyncs();
    if (!isAcceptingNewSyncs) {
      throw new NewSyncsForbiddenException();
    }

    // Check if daily new syncs limit has been hit if config value enabled
    if (Config.get().dailyNewSyncsLimit > 0) {
      const newSyncsLimitHit = await this.service.newSyncsLimitHit(req);
      if (newSyncsLimitHit) {
        throw new NewSyncsLimitExceededException();
      }
    }

    try {
      // Create new bookmarks payload
      const newBookmarks: IBookmarks = {
        version: syncVersion,
      };
      const bookmarksModel = new BookmarksModel(newBookmarks);

      // Commit the bookmarks payload to the db
      const savedBookmarks = await bookmarksModel.save();

      // Add to logs
      if (Config.get().dailyNewSyncsLimit > 0) {
        await this.service.createLog(req);
      }
      this.log(LogLevel.Info, 'New bookmarks sync created', req);

      // Return the response data
      const returnObj: ICreateBookmarksResponse = {
        id: savedBookmarks._id,
        lastUpdated: savedBookmarks.lastUpdated,
        version: savedBookmarks.version,
      };
      return returnObj;
    } catch (err) {
      this.log(LogLevel.Error, 'Exception occurred in BookmarksService.createBookmarks', req, err);
      throw err;
    }
  }

  // Retrieves an existing bookmarks sync using the supplied sync ID
  async getBookmarks(id: string, req: Request): Promise<IGetBookmarksResponse> {
    // Before proceeding, check service is available
    checkServiceAvailability();

    try {
      // Query the db for the existing bookmarks data and update the last accessed date
      const updatedBookmarks = await BookmarksModel.findOneAndUpdate(
        { _id: id },
        { lastAccessed: new Date() },
        { new: true }
      ).exec();

      if (!updatedBookmarks) {
        throw new SyncNotFoundException();
      }

      // Return the existing bookmarks data if found
      const response: IGetBookmarksResponse = {
        bookmarks: updatedBookmarks.bookmarks,
        version: updatedBookmarks.version,
        lastUpdated: updatedBookmarks.lastUpdated,
      };
      return response;
    } catch (err) {
      if (!(err instanceof SyncNotFoundException)) {
        this.log(LogLevel.Error, 'Exception occurred in BookmarksService.getBookmarks', req, err);
      }
      throw err;
    }
  }

  // Returns the last updated date for the supplied sync ID
  async getLastUpdated(id: string, req: Request): Promise<IGetLastUpdatedResponse> {
    // Before proceeding, check service is available
    checkServiceAvailability();

    try {
      // Query the db for the existing bookmarks data and update the last accessed date
      const updatedBookmarks = await BookmarksModel.findOneAndUpdate(
        { _id: id },
        { lastAccessed: new Date() },
        { new: true }
      ).exec();

      if (!updatedBookmarks) {
        throw new SyncNotFoundException();
      }

      // Return the last updated date if bookmarks data found
      const response: IGetLastUpdatedResponse = {
        lastUpdated: updatedBookmarks.lastUpdated,
      };
      return response;
    } catch (err) {
      if (!(err instanceof SyncNotFoundException)) {
        this.log(LogLevel.Error, 'Exception occurred in BookmarksService.getLastUpdated', req, err);
      }
      throw err;
    }
  }

  // Returns the sync version for the supplied sync ID
  async getVersion(id: string, req: Request): Promise<IGetVersionResponse> {
    // Before proceeding, check service is available
    checkServiceAvailability();

    try {
      // Query the db for the existing bookmarks data and update the last accessed date
      const updatedBookmarks = await BookmarksModel.findOneAndUpdate(
        { _id: id },
        { lastAccessed: new Date() },
        { new: true }
      ).exec();

      if (!updatedBookmarks) {
        throw new SyncNotFoundException();
      }

      // Return the last updated date if bookmarks data found
      const response: IGetVersionResponse = {
        version: updatedBookmarks.version,
      };
      return response;
    } catch (err) {
      if (!(err instanceof SyncNotFoundException)) {
        this.log(LogLevel.Error, 'Exception occurred in BookmarksService.getVersion', req, err);
      }
      throw err;
    }
  }

  // Returns true/false depending whether the service is currently accepting new syncs
  async isAcceptingNewSyncs(): Promise<boolean> {
    // Check if allowNewSyncs config value enabled
    if (!Config.get().status.allowNewSyncs) {
      return false;
    }

    // Check if maxSyncs config value disabled
    if (Config.get().maxSyncs === 0) {
      return true;
    }

    // Check if total syncs have reached limit set in config
    const bookmarksCount = await this.getBookmarksCount();
    return bookmarksCount < Config.get().maxSyncs;
  }

  // Updates an existing bookmarks sync corresponding to the supplied sync ID with the supplied bookmarks data
  async updateBookmarks_v1(id: string, bookmarksData: string, req: Request): Promise<IUpdateBookmarksResponse> {
    // Before proceeding, check service is available
    checkServiceAvailability();

    try {
      // Update the bookmarks data corresponding to the sync id in the db
      const now = new Date();
      const updatedBookmarks = await BookmarksModel.findOneAndUpdate(
        { _id: id },
        {
          bookmarks: bookmarksData,
          lastAccessed: now,
          lastUpdated: now,
        },
        { new: true }
      ).exec();

      // Return the last updated date if bookmarks data found and updated
      const response: IGetLastUpdatedResponse = {};
      if (updatedBookmarks) {
        response.lastUpdated = updatedBookmarks.lastUpdated;
      }

      return response;
    } catch (err) {
      this.log(LogLevel.Error, 'Exception occurred in BookmarksService.createBookmarks', req, err);
      throw err;
    }
  }

  // Updates an existing bookmarks sync corresponding to the supplied sync ID with the supplied bookmarks and version data
  async updateBookmarks_v2(
    id: string,
    bookmarksData: string,
    lastUpdated: string,
    syncVersion: string,
    req: Request
  ): Promise<IUpdateBookmarksResponse> {
    // Before proceeding, check service is available
    checkServiceAvailability();

    // Create update payload
    const now = new Date();
    const updatePayload: IBookmarks = {
      bookmarks: bookmarksData,
      lastAccessed: now,
      lastUpdated: now,
    };
    if (syncVersion) {
      updatePayload.version = syncVersion;
    }

    try {
      // Get the existing bookmarks using the supplied id
      const existingBookmarks = await BookmarksModel.findById(id).exec();
      if (!existingBookmarks) {
        throw new SyncNotFoundException();
      }

      // Check for sync conflicts using the supplied lastUpdated value
      if (lastUpdated && lastUpdated !== existingBookmarks.lastUpdated.toISOString()) {
        throw new SyncConflictException();
      }

      // Update the bookmarks data corresponding to the sync id in the db
      const updatedBookmarks = await BookmarksModel.findOneAndUpdate({ _id: id }, updatePayload, { new: true }).exec();

      // Return the last updated date if bookmarks data found and updated
      const response: IGetLastUpdatedResponse = {
        lastUpdated: updatedBookmarks.lastUpdated,
      };

      return response;
    } catch (err) {
      if (!(err instanceof SyncNotFoundException)) {
        this.log(LogLevel.Error, 'Exception occurred in BookmarksService.createBookmarks', req, err);
      }
      throw err;
    }
  }

  // Returns the total number of existing bookmarks syncs
  async getBookmarksCount(): Promise<number> {
    let bookmarksCount = -1;

    try {
      bookmarksCount = await BookmarksModel.estimatedDocumentCount().exec();
    } catch (err) {
      this.log(LogLevel.Error, 'Exception occurred in BookmarksService.getBookmarksCount', null, err);
      throw err;
    }

    // Ensure a valid count was returned
    if (bookmarksCount < 0) {
      const err = new UnspecifiedException('Bookmarks count cannot be less than zero');
      this.log(LogLevel.Error, 'Exception occurred in NewSyncLogsService.newSyncsLimitHit', null, err);
      throw err;
    }

    return bookmarksCount;
  }
}
</file>

<file path="src/services/info.service.spec.ts">
import 'jest';
import { Request } from 'express';
import { LogLevel, ServiceStatus } from '../common/enums';
import * as Config from '../config';
import { BookmarksService } from './bookmarks.service';
import { InfoService } from './info.service';

jest.mock('./bookmarks.service');

describe('InfoService', () => {
  let logMock: jest.Mock<any, any>;

  beforeEach(() => {
    logMock = jest.fn();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('getInfo: should return location config value', async () => {
    const locationTest = 'gb';
    const configSettingsTest: Config.IConfigSettings = {
      location: locationTest,
      status: {
        online: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(null, jest.fn());
    const infoService = new InfoService(bookmarksService, jest.fn());
    const req: Partial<Request> = {};
    const response = await infoService.getInfo(req as Request);
    expect(response.location).toStrictEqual(locationTest.toUpperCase());
  });

  it('getInfo: should return max sync size config value', async () => {
    const maxSyncSizeTest = 1;
    const configSettingsTest: Config.IConfigSettings = {
      maxSyncSize: maxSyncSizeTest,
      status: {
        online: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(null, jest.fn());
    const infoService = new InfoService(bookmarksService, jest.fn());
    const req: Partial<Request> = {};
    const response = await infoService.getInfo(req as Request);
    expect(response.maxSyncSize).toStrictEqual(maxSyncSizeTest);
  });

  it('getInfo: should return message config value', async () => {
    const messageTest = 'Test API message';
    const configSettingsTest: Config.IConfigSettings = {
      status: {
        message: messageTest,
        online: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(null, jest.fn());
    const infoService = new InfoService(bookmarksService, jest.fn());
    const req: Partial<Request> = {};
    const response = await infoService.getInfo(req as Request);
    expect(response.message).toStrictEqual(messageTest);
  });

  it('getInfo: should strip script tags from message config value', async () => {
    const messageTest = `<script>alert('test');</script>`;
    const configSettingsTest: Config.IConfigSettings = {
      status: {
        message: messageTest,
        online: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(null, jest.fn());
    const infoService = new InfoService(bookmarksService, jest.fn());
    const req: Partial<Request> = {};
    const response = await infoService.getInfo(req as Request);
    expect(response.message).toStrictEqual('');
  });

  it('getInfo: should return correct API status when online', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      status: {
        online: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(null, jest.fn());
    const infoService = new InfoService(bookmarksService, jest.fn());
    const req: Partial<Request> = {};
    const response = await infoService.getInfo(req as Request);
    expect(response.status).toStrictEqual(ServiceStatus.online);
  });

  it('getInfo: should return correct API status when offline', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      status: {
        online: false,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(null, jest.fn());
    const infoService = new InfoService(bookmarksService, jest.fn());
    const req: Partial<Request> = {};
    const response = await infoService.getInfo(req as Request);
    expect(response.status).toStrictEqual(ServiceStatus.offline);
  });

  it('getInfo: should return version config value', async () => {
    const versionTest = '0.0.0';
    const configSettingsTest: Config.IConfigSettings = {
      status: {
        online: false,
      },
      version: versionTest,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(true);
    const bookmarksService = new BookmarksService(null, jest.fn());
    const infoService = new InfoService(bookmarksService, jest.fn());
    const req: Partial<Request> = {};
    const response = await infoService.getInfo(req as Request);
    expect(response.version).toStrictEqual(versionTest);
  });

  it('getInfo: should return correct API status when not accepting new syncs', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      status: {
        online: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockResolvedValue(false);
    const bookmarksService = new BookmarksService(null, jest.fn());
    const infoService = new InfoService(bookmarksService, jest.fn());
    const req: Partial<Request> = {};
    const response = await infoService.getInfo(req as Request);
    expect(response.status).toStrictEqual(ServiceStatus.noNewSyncs);
  });

  it('getInfo: should catch and log errors', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      status: {
        online: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const errorTest = new Error();
    jest.spyOn(BookmarksService.prototype, 'isAcceptingNewSyncs').mockImplementation(() => {
      throw errorTest;
    });
    const bookmarksService = new BookmarksService(null, logMock);
    const infoService = new InfoService(bookmarksService, logMock);
    const req: Partial<Request> = {};
    expect(async () => {
      await infoService.getInfo(req as Request);
    }).not.toThrowError();
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), req, errorTest);
  });

  it('stripScriptsFromHtml: should return an empty string when passed a null value', () => {
    const infoService = new InfoService(null, null);
    const result = infoService.stripScriptsFromHtml(null);
    expect(result).toStrictEqual('');
  });

  it('stripScriptsFromHtml: should strip script tags and return a cleaned string', () => {
    const infoService = new InfoService(null, null);
    const result = infoService.stripScriptsFromHtml('Lorem <script type="text/javascript">test</script>Ipsum');
    expect(result).toStrictEqual('Lorem Ipsum');
  });
});
</file>

<file path="src/services/info.service.ts">
import { Request } from 'express';
import { LogLevel, ServiceStatus } from '../common/enums';
import * as Config from '../config';
import { ApiService } from './api.service';
import { BookmarksService } from './bookmarks.service';

// Interface for get info operation response object
export interface IGetInfoResponse {
  location: string;
  maxSyncSize: number;
  message: string;
  status: number;
  version: string;
}

// Implementation of data service for service info operations
export class InfoService extends ApiService<BookmarksService> {
  // Returns information describing the xBrowserSync service
  async getInfo(req: Request): Promise<IGetInfoResponse> {
    // Convert location code to uppercase if set
    const location = Config.get().location && (Config.get().location as string).toUpperCase();

    // Create response object from config settings
    const serviceInfo: IGetInfoResponse = {
      location,
      maxSyncSize: Config.get().maxSyncSize,
      message: this.stripScriptsFromHtml(Config.get().status.message),
      status: ServiceStatus.offline,
      version: Config.get().version,
    };

    if (Config.get().status.online) {
      try {
        // Call service method to check if accepting new syncs
        const acceptingNewSyncs = await this.service.isAcceptingNewSyncs();
        serviceInfo.status = acceptingNewSyncs ? ServiceStatus.online : ServiceStatus.noNewSyncs;
      } catch (err) {
        this.log(LogLevel.Error, 'Exception occurred in InfoService.getInfo', req, err);
      }
    }

    return serviceInfo;
  }

  // Removes script tags from a given HTML string
  stripScriptsFromHtml(html: string): string {
    return !html ? '' : html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
  }
}
</file>

<file path="src/services/newSyncLogs.service.spec.ts">
import 'jest';
import { Request } from 'express';
import { LogLevel } from '../common/enums';
import * as Config from '../config';
import { UnspecifiedException } from '../exception';
import { NewSyncLogsModel } from '../models/newSyncLogs.model';
import { NewSyncLogsService } from './newSyncLogs.service';

jest.mock('../models/newSyncLogs.model');

describe('NewSyncLogsService', () => {
  const ipAddressTest = '123.456.789.0';
  let logMock: jest.Mock<any, any>;

  beforeEach(() => {
    logMock = jest.fn();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('createLog: should create a new sync log using the request IP address', async () => {
    const getClientIpAddressMock = jest
      .spyOn(NewSyncLogsService.prototype, 'getClientIpAddress')
      .mockReturnValue(ipAddressTest);
    jest.spyOn(NewSyncLogsModel.prototype, 'save').mockResolvedValue(null);
    const newSyncLogsService = new NewSyncLogsService(null, jest.fn());
    const req: Partial<Request> = {};
    const savedTestLog = await newSyncLogsService.createLog(req as Request);
    expect(getClientIpAddressMock).toHaveBeenCalledWith(req);
    expect(savedTestLog.ipAddress).toStrictEqual(ipAddressTest);
  });

  it('createLog: should log error if encoutered when saving document to db', async () => {
    jest.spyOn(NewSyncLogsService.prototype, 'getClientIpAddress').mockReturnValue(ipAddressTest);
    const errorTest = new Error();
    jest.spyOn(NewSyncLogsModel.prototype, 'save').mockImplementation(() => {
      throw errorTest;
    });
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    const req: Partial<Request> = {};
    await expect(newSyncLogsService.createLog(req as Request)).rejects.toThrow(errorTest);
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), req, errorTest);
  });

  it('createLog: should return null if the request IP address could not be ascertained', async () => {
    jest.spyOn(NewSyncLogsService.prototype, 'getClientIpAddress').mockReturnValue(null);
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    const req: Partial<Request> = {};
    const response = await newSyncLogsService.createLog(req as Request);
    expect(response).toBeNull();
    expect(logMock).toHaveBeenCalledWith(LogLevel.Info, expect.any(String));
  });

  it('newSyncsLimitHit: should return true if the request IP address has hit the limit for daily new syncs created', async () => {
    jest.spyOn(NewSyncLogsService.prototype, 'getClientIpAddress').mockReturnValue(ipAddressTest);
    const configSettingsTest: Config.IConfigSettings = {
      dailyNewSyncsLimit: 1,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const countDocumentsMock = jest.spyOn(NewSyncLogsModel, 'countDocuments').mockReturnValue({
      exec: () => Promise.resolve(1),
    } as any);
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    const req: Partial<Request> = {};
    const limitHit = await newSyncLogsService.newSyncsLimitHit(req as Request);
    expect(countDocumentsMock).toHaveBeenCalledWith({ ipAddress: ipAddressTest });
    expect(limitHit).toBe(true);
  });

  it('newSyncsLimitHit: should return false if the request IP address has not hit the limit for daily new syncs created', async () => {
    jest.spyOn(NewSyncLogsService.prototype, 'getClientIpAddress').mockReturnValue(ipAddressTest);
    const dailyNewSyncsLimitTest = 1;
    const configSettingsTest: Config.IConfigSettings = {
      dailyNewSyncsLimit: dailyNewSyncsLimitTest,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const countDocumentsMock = jest.spyOn(NewSyncLogsModel, 'countDocuments').mockReturnValue({
      exec: () => Promise.resolve(0),
    } as any);
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    const req: Partial<Request> = {};
    const limitHit = await newSyncLogsService.newSyncsLimitHit(req as Request);
    expect(countDocumentsMock).toHaveBeenCalledWith({ ipAddress: ipAddressTest });
    expect(limitHit).toBe(false);
  });

  it('newSyncsLimitHit: should return null if the request IP address could not be ascertained', async () => {
    jest.spyOn(NewSyncLogsService.prototype, 'getClientIpAddress').mockReturnValue(null);
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    const req: Partial<Request> = {};
    const response = await newSyncLogsService.newSyncsLimitHit(req as Request);
    expect(response).toBeNull();
    expect(logMock).toHaveBeenCalledWith(LogLevel.Info, expect.any(String));
  });

  it('newSyncsLimitHit: should log error if encoutered when retrieving documents count from db', async () => {
    jest.spyOn(NewSyncLogsService.prototype, 'getClientIpAddress').mockReturnValue(ipAddressTest);
    const errorTest = new Error();
    jest.spyOn(NewSyncLogsModel, 'countDocuments').mockImplementation(() => {
      throw errorTest;
    });
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    const req: Partial<Request> = {};
    await expect(newSyncLogsService.newSyncsLimitHit(req as Request)).rejects.toThrow(errorTest);
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), req, errorTest);
  });

  it('newSyncsLimitHit: should log error if countDocuments returns a value less than zero', async () => {
    jest.spyOn(NewSyncLogsService.prototype, 'getClientIpAddress').mockReturnValue(ipAddressTest);
    jest.spyOn(NewSyncLogsModel, 'countDocuments').mockReturnValue({
      exec: () => Promise.resolve(-1),
    } as any);
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    const req: Partial<Request> = {};
    await expect(newSyncLogsService.newSyncsLimitHit(req as Request)).rejects.toThrow(UnspecifiedException);
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), req, expect.any(UnspecifiedException));
  });

  it('getClientIpAddress: should return the ip address associated with the request', () => {
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    const req: Partial<Request> = {
      ip: ipAddressTest,
    };
    const ipAddress = newSyncLogsService.getClientIpAddress(req as Request);
    expect(ipAddress).toStrictEqual(ipAddressTest);
  });

  it('getClientIpAddress: should return null if no request object provided', () => {
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    const ipAddress = newSyncLogsService.getClientIpAddress(null);
    expect(ipAddress).toBeNull();
  });

  it('getClientIpAddress: should return null if no ip address associated with the request object provided', () => {
    const newSyncLogsService = new NewSyncLogsService(null, logMock);
    const req: Partial<Request> = {};
    const ipAddress = newSyncLogsService.getClientIpAddress(req as Request);
    expect(ipAddress).toBeNull();
  });
});
</file>

<file path="src/services/newSyncLogs.service.ts">
import { Request } from 'express';
import { LogLevel } from '../common/enums';
import * as Config from '../config';
import { UnspecifiedException } from '../exception';
import { INewSyncLog, NewSyncLogsModel } from '../models/newSyncLogs.model';
import { ApiService } from './api.service';

// Implementation of data service for new sync log operations
export class NewSyncLogsService extends ApiService<void> {
  // Creates a new sync log entry with the supplied request data
  async createLog(req: Request): Promise<INewSyncLog> {
    // Get the client's ip address
    const clientIp = this.getClientIpAddress(req);
    if (!clientIp) {
      this.log(LogLevel.Info, 'Unable to determine client IP address');
      return null;
    }

    // Create new sync log payload
    const newLogPayload: INewSyncLog = {
      ipAddress: clientIp,
    };
    const newSyncLogsModel = new NewSyncLogsModel(newLogPayload);

    // Commit the payload to the db
    try {
      await newSyncLogsModel.save();
    } catch (err) {
      this.log(LogLevel.Error, 'Exception occurred in NewSyncLogsService.createLog', req, err);
      throw err;
    }

    return newLogPayload;
  }

  // Returns true/false depending on whether a given request's ip address has hit the limit for daily new syncs created
  async newSyncsLimitHit(req: Request): Promise<boolean> {
    // Get the client's ip address
    const clientIp = this.getClientIpAddress(req);
    if (!clientIp) {
      this.log(LogLevel.Info, 'Unable to determine client IP address');
      return null;
    }

    let newSyncsCreated = -1;

    // Query the newsynclogs collection for the total number of logs for the given ip address
    try {
      newSyncsCreated = await NewSyncLogsModel.countDocuments({ ipAddress: clientIp }).exec();
    } catch (err) {
      this.log(LogLevel.Error, 'Exception occurred in NewSyncLogsService.newSyncsLimitHit', req, err);
      throw err;
    }

    // Ensure a valid count was returned
    if (newSyncsCreated < 0) {
      const err = new UnspecifiedException('New syncs created count cannot be less than zero');
      this.log(LogLevel.Error, 'Exception occurred in NewSyncLogsService.newSyncsLimitHit', req, err);
      throw err;
    }

    // Check returned count against config setting
    return newSyncsCreated >= Config.get().dailyNewSyncsLimit;
  }

  // Extracts the client's ip address from a given request
  getClientIpAddress(req: Request): string {
    if (!req || !req.ip) {
      return null;
    }

    return req.ip;
  }
}
</file>

<file path="src/api.ts">
import { createApplication, startService } from './server';

// Entry point into server
export default (async () => {
  const app = await createApplication();
  await startService(app);
})();
</file>

<file path="src/config.spec.ts">
import 'jest';
import fs from 'fs';
import path from 'path';
import * as Config from './config';

describe('Config', () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('get: should return cached config if force set to false', () => {
    const cachedConfigTest = {};
    const getCachedConfigMock = jest.spyOn(Config, 'getCachedConfig').mockReturnValue(cachedConfigTest);
    const getUserSettingsSpy = jest.spyOn(Config, 'getUserSettings');
    const config = Config.get(false);
    expect(getCachedConfigMock).toHaveBeenCalled();
    expect(config).toBe(cachedConfigTest);
    expect(getUserSettingsSpy).not.toHaveBeenCalled();
  });

  it('get: should return default settings values when no user settings provided', () => {
    jest.spyOn(Config, 'getUserSettings').mockImplementation(() => {
      return {};
    });
    const maxSyncs = Config.get(true).maxSyncs;
    expect(maxSyncs).toBe(5242);
  });

  it('get: should return user settings values when user settings provided', () => {
    const maxSyncsTestVal = 9999;
    jest.spyOn(Config, 'getUserSettings').mockReturnValue({
      maxSyncs: maxSyncsTestVal,
    });
    const maxSyncs = Config.get(true).maxSyncs;
    expect(maxSyncs).toStrictEqual(maxSyncsTestVal);
  });

  it('get: should return package version number', () => {
    const versionTestVal = '1.1.1';
    jest.spyOn(Config, 'getPackageVersion').mockReturnValue(versionTestVal);
    const version = Config.get(true).version;
    expect(version).toStrictEqual(versionTestVal);
  });

  it('getUserSettings: should return an empty object if no user settings exist', () => {
    jest.spyOn(path, 'join').mockReturnValue(null);
    jest.spyOn(fs, 'existsSync').mockReturnValue(false);
    const userSettings = Config.getUserSettings(null);
    expect(userSettings).toStrictEqual({});
  });
});
</file>

<file path="src/config.ts">
import merge from 'deepmerge';
import fs from 'fs';
import path from 'path';

export interface IConfigSettings {
  allowedOrigins?: string[];
  dailyNewSyncsLimit?: number;
  db?: {
    authSource?: string;
    connTimeout?: number;
    host?: string;
    name?: string;
    ssl?: boolean;
    useSRV?: boolean;
    username?: string;
    password?: string;
    port?: number;
  };
  location?: string;
  log?: {
    file?: {
      enabled?: boolean;
      level?: 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'fatal';
      path?: string;
      rotatedFilesToKeep?: number;
      rotationPeriod?: string;
    };
    stdout?: {
      enabled?: boolean;
      level?: string;
    };
  };
  maxSyncs?: number;
  maxSyncSize?: number;
  server?: {
    behindProxy?: boolean;
    host?: string;
    https?: {
      certPath?: string;
      enabled?: boolean;
      keyPath?: string;
    };
    port?: number;
    relativePath?: string;
  };
  status?: {
    allowNewSyncs?: boolean;
    message?: string;
    online?: boolean;
  };
  tests?: {
    db?: string;
    port?: number;
  };
  throttle?: {
    maxRequests?: number;
    timeWindow?: number;
  };
  version?: string;
}

let cachedConfig: IConfigSettings;
export const getCachedConfig = (): IConfigSettings => {
  return cachedConfig;
};
export const setCachedConfig = (value: IConfigSettings): void => {
  cachedConfig = value;
};

// Returns combined default and user-specified config settings
export const get = (force?: boolean): IConfigSettings => {
  if (getCachedConfig() && !force) {
    return getCachedConfig();
  }

  // Get full path to config folder
  const pathToConfig = path.join(__dirname, '../config');

  // Get default settings values
  const defaultSettings = getDefaultSettings(pathToConfig);

  // Get user settings values if present
  const userSettings = getUserSettings(pathToConfig);

  // Merge default and user settings
  const settings: any = merge(defaultSettings, userSettings);

  // Get current version number
  const version = getPackageVersion();

  setCachedConfig({
    ...settings,
    version,
  });

  return getCachedConfig();
};

// Returns default config settings
const getDefaultSettings = (pathToConfig: string): IConfigSettings => {
  const pathToSettings = path.join(pathToConfig, 'settings.default.json');
  return require(pathToSettings);
};

// Returns version number from package.json
export const getPackageVersion = (): string => {
  const packageJson = require('../package.json');
  return packageJson.version;
};

// Returns user-specified config settings
export const getUserSettings = (pathToConfig: string): IConfigSettings => {
  const pathToUserSettings = path.join(pathToConfig, 'settings.json');
  let userSettings: IConfigSettings = {};
  if (fs.existsSync(pathToUserSettings)) {
    userSettings = require(pathToUserSettings);
  }
  return userSettings;
};
</file>

<file path="src/db.spec.ts">
import 'jest';
import mongoose from 'mongoose';
import { LogLevel } from './common/enums';
import * as Config from './config';
import { connect, disconnect } from './db';

jest.mock('mongoose');

describe('DB', () => {
  const authSourceTest = 'authSourceTest';
  const dbNameTest = 'dbNameTest';
  const hostnameTest = 'hostnameTest';
  const passwordTest = 'passwordTest';
  const portTest = 12345;
  const usernameTest = 'usernameTest';

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('connect: should call mongoose.connect', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {},
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const connectMock = jest.spyOn(mongoose, 'connect').mockImplementation();
    connect();
    expect(connectMock).toHaveBeenCalled();
  });

  it('connect: should use standard connection uri by default', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {},
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`mongodb://`));
  });

  it('connect: should use srv connection uri if specified in config settings', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {
        useSRV: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`mongodb\\+srv://`));
  });

  it('connect: should include username from config settings in standard connection uri', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {
        username: usernameTest,
        password: passwordTest,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`://${usernameTest}:`));
  });

  it('connect: should include username from config settings in srv connection uri', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {
        username: usernameTest,
        password: passwordTest,
        useSRV: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`://${usernameTest}:`));
  });

  it('connect: should include username from environment variables in connection uri if no username defined in config settings', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {},
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    process.env.XBROWSERSYNC_DB_USER = usernameTest;
    process.env.XBROWSERSYNC_DB_PWD = passwordTest;
    connect();
    expect(connectionUri).toMatch(new RegExp(`://${usernameTest}:`));
  });

  it('connect: should include password from config settings in standard connection uri', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {
        username: usernameTest,
        password: passwordTest,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`://.*:${passwordTest}@`));
  });

  it('connect: should include password from config settings in srv connection uri', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {
        username: usernameTest,
        password: passwordTest,
        useSRV: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`://.*:${passwordTest}@`));
  });

  it('connect: should include password from environment variables in connection uri if no password defined in config settings', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {},
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    process.env.XBROWSERSYNC_DB_USER = usernameTest;
    process.env.XBROWSERSYNC_DB_PWD = passwordTest;
    connect();
    expect(connectionUri).toMatch(new RegExp(`://.*:${passwordTest}@`));
  });

  it('connect: should include authSource from config settings in standard connection uri', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {
        authSource: authSourceTest,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`\\?authSource=${authSourceTest}$`));
  });

  it('connect: should include authSource from config settings in srv connection uri', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {
        authSource: authSourceTest,
        useSRV: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`\\?authSource=${authSourceTest}$`));
  });

  it('connect: should include hostname from config settings in standard connection uri', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {
        host: hostnameTest,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`@${hostnameTest}`));
  });

  it('connect: should include hostname from config settings in srv connection uri', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {
        host: hostnameTest,
        useSRV: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`@${hostnameTest}`));
  });

  it('connect: should include port from config settings in standard connection uri', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {
        port: portTest,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`:${portTest}/`));
  });

  it('connect: should include db name from config settings in standard connection uri', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {
        name: dbNameTest,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`/${dbNameTest}`));
  });

  it('connect: should include db name from config settings in srv connection uri', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {
        name: dbNameTest,
        useSRV: true,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    let connectionUri: string;
    jest.spyOn(mongoose, 'connect').mockImplementation((...args) => {
      connectionUri = args[0];
      return Promise.resolve(require('mongoose'));
    });
    connect();
    expect(connectionUri).toMatch(new RegExp(`/${dbNameTest}`));
  });

  it('connect: should exit process with error if db connection fails', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      db: {},
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const exitMock = jest.spyOn(process, 'exit').mockImplementation();
    const errorTest = new Error();
    jest.spyOn(mongoose, 'connect').mockRejectedValue(errorTest);
    const logMock = jest.fn();
    await connect(logMock);
    expect(exitMock).toHaveBeenCalledWith(1);
    expect(logMock).toHaveBeenCalledWith(LogLevel.Error, expect.any(String), null, errorTest);
  });

  it('disconnect: should call mongoose.disconnect', async () => {
    const disconnectMock = jest.spyOn(mongoose, 'disconnect');
    disconnect();
    expect(disconnectMock).toHaveBeenCalled();
  });
});
</file>

<file path="src/db.ts">
import { Request } from 'express';
import mongoose from 'mongoose';
import { LogLevel } from './common/enums';
import * as Config from './config';

// Initialises the database connection using config settings
export const connect = async (
  log?: (level: LogLevel, message: string, req?: Request, err?: Error) => void
): Promise<void> => {
  // Set the db connection options from config settings
  const options: mongoose.ConnectionOptions = {
    connectTimeoutMS: Config.get().db.connTimeout,
    keepAlive: true,
    ssl: Config.get().db.useSRV || Config.get().db.ssl,
    useFindAndModify: false,
    useNewUrlParser: true,
    useUnifiedTopology: true,
  };

  // Configure db credentials
  const username = Config.get().db.username || process.env.XBROWSERSYNC_DB_USER;
  const password = Config.get().db.password || process.env.XBROWSERSYNC_DB_PWD;
  const creds = username && password ? `${encodeURIComponent(username)}:${encodeURIComponent(password)}@` : '';

  // Create mongo connection uri using host and db name defined in config settings
  let dbServerUrl = 'mongodb';
  if (Config.get().db.useSRV) {
    dbServerUrl += `+srv://${creds}${Config.get().db.host}/${Config.get().db.name}`;
  } else {
    dbServerUrl += `://${creds}${Config.get().db.host}:${Config.get().db.port}/${Config.get().db.name}`;
  }
  dbServerUrl += Config.get().db.authSource ? `?authSource=${Config.get().db.authSource}` : '';

  // Connect to the database
  try {
    await mongoose.connect(dbServerUrl, options);
  } catch (err) {
    if ((log ?? undefined) !== undefined) {
      log(LogLevel.Error, 'Unable to connect to database', null, err);
    }
    process.exit(1);
  }
};

// Closes the database connection
export const disconnect = async (): Promise<void> => {
  await mongoose.disconnect();
};
</file>

<file path="src/exception.spec.ts">
import 'jest';
import {
  ApiException,
  InvalidArgumentException,
  InvalidSyncIdException,
  NewSyncsForbiddenException,
  NewSyncsLimitExceededException,
  NotImplementedException,
  OriginNotPermittedException,
  RequestThrottledException,
  RequiredDataNotFoundException,
  SyncConflictException,
  SyncDataLimitExceededException,
  UnspecifiedException,
  UnsupportedVersionException,
} from './exception';

describe('Exception', () => {
  it('getResponseObject: should return exception reponse object', () => {
    const exception = new UnspecifiedException();
    const response = exception.getResponseObject();
    expect(response.code).toBeDefined();
    expect(response.message).toBeDefined();
  });

  it('InvalidArgumentException should define properties', () => {
    let exception: ApiException;
    expect(() => {
      try {
        throw new InvalidArgumentException();
      } catch (err) {
        exception = err;
        throw err;
      }
    }).toThrow(InvalidArgumentException);
    expect(typeof exception.message).toBe('string');
    expect(typeof exception.name).toBe('string');
  });

  it('InvalidSyncIdException should define properties', () => {
    let exception: ApiException;
    expect(() => {
      try {
        throw new InvalidSyncIdException();
      } catch (err) {
        exception = err;
        throw err;
      }
    }).toThrow(InvalidSyncIdException);
    expect(typeof exception.message).toBe('string');
    expect(typeof exception.name).toBe('string');
    expect(typeof exception.status).toBe('number');
  });

  it('RequiredDataNotFoundException should define properties', () => {
    let exception: ApiException;
    expect(() => {
      try {
        throw new RequiredDataNotFoundException();
      } catch (err) {
        exception = err;
        throw err;
      }
    }).toThrow(RequiredDataNotFoundException);
    expect(typeof exception.message).toBe('string');
    expect(typeof exception.name).toBe('string');
    expect(typeof exception.status).toBe('number');
  });

  it('NewSyncsForbiddenException should define properties', () => {
    let exception: ApiException;
    expect(() => {
      try {
        throw new NewSyncsForbiddenException();
      } catch (err) {
        exception = err;
        throw err;
      }
    }).toThrow(NewSyncsForbiddenException);
    expect(typeof exception.message).toBe('string');
    expect(typeof exception.name).toBe('string');
    expect(typeof exception.status).toBe('number');
  });

  it('NewSyncsLimitExceededException should define properties', () => {
    let exception: ApiException;
    expect(() => {
      try {
        throw new NewSyncsLimitExceededException();
      } catch (err) {
        exception = err;
        throw err;
      }
    }).toThrow(NewSyncsLimitExceededException);
    expect(typeof exception.message).toBe('string');
    expect(typeof exception.name).toBe('string');
    expect(typeof exception.status).toBe('number');
  });

  it('NotImplementedException should define properties', () => {
    let exception: ApiException;
    expect(() => {
      try {
        throw new NotImplementedException();
      } catch (err) {
        exception = err;
        throw err;
      }
    }).toThrow(NotImplementedException);
    expect(typeof exception.message).toBe('string');
    expect(typeof exception.name).toBe('string');
    expect(typeof exception.status).toBe('number');
  });

  it('SyncConflictException should define properties', () => {
    let exception: ApiException;
    expect(() => {
      try {
        throw new SyncConflictException();
      } catch (err) {
        exception = err;
        throw err;
      }
    }).toThrow(SyncConflictException);
    expect(typeof exception.message).toBe('string');
    expect(typeof exception.name).toBe('string');
    expect(typeof exception.status).toBe('number');
  });

  it('UnsupportedVersionException should define properties', () => {
    let exception: ApiException;
    expect(() => {
      try {
        throw new UnsupportedVersionException();
      } catch (err) {
        exception = err;
        throw err;
      }
    }).toThrow(UnsupportedVersionException);
    expect(typeof exception.message).toBe('string');
    expect(typeof exception.name).toBe('string');
    expect(typeof exception.status).toBe('number');
  });

  it('SyncDataLimitExceededException should define properties', () => {
    let exception: ApiException;
    expect(() => {
      try {
        throw new SyncDataLimitExceededException();
      } catch (err) {
        exception = err;
        throw err;
      }
    }).toThrow(SyncDataLimitExceededException);
    expect(typeof exception.message).toBe('string');
    expect(typeof exception.name).toBe('string');
    expect(typeof exception.status).toBe('number');
  });

  it('RequestThrottledException should define properties', () => {
    let exception: ApiException;
    expect(() => {
      try {
        throw new RequestThrottledException();
      } catch (err) {
        exception = err;
        throw err;
      }
    }).toThrow(RequestThrottledException);
    expect(typeof exception.message).toBe('string');
    expect(typeof exception.name).toBe('string');
    expect(typeof exception.status).toBe('number');
  });

  it('OriginNotPermittedException should define properties', () => {
    let exception: ApiException;
    expect(() => {
      try {
        throw new OriginNotPermittedException();
      } catch (err) {
        exception = err;
        throw err;
      }
    }).toThrow(OriginNotPermittedException);
    expect(typeof exception.message).toBe('string');
    expect(typeof exception.name).toBe('string');
    expect(typeof exception.status).toBe('number');
  });

  it('UnspecifiedException should define properties', () => {
    let exception: ApiException;
    expect(() => {
      try {
        throw new UnspecifiedException();
      } catch (err) {
        exception = err;
        throw err;
      }
    }).toThrow(UnspecifiedException);
    expect(typeof exception.message).toBe('string');
    expect(typeof exception.name).toBe('string');
    expect(typeof exception.status).toBe('number');
  });
});
</file>

<file path="src/exception.ts">
/* eslint-disable max-classes-per-file */

// Base class for custom api exceptions
export class ApiException extends Error {
  message: string;
  name: string;
  status: number;

  getResponseObject(): any {
    return {
      code: this.name,
      message: this.message,
    };
  }
}

export class InvalidArgumentException extends Error {
  constructor(message?: string) {
    super(message || 'Supplied argument has incorrect type');
    this.name = 'InvalidArgumentException';
  }
}

export class InvalidSyncIdException extends ApiException {
  constructor(message?: string) {
    super(message || 'Invalid sync ID');
    this.name = 'InvalidSyncIdException';
    this.status = 401; // Unauthorized
  }
}

export class SyncNotFoundException extends ApiException {
  constructor(message?: string) {
    super(message || 'Sync does not exist');
    this.name = 'SyncNotFoundException';
    this.status = 401; // Unauthorized
  }
}

export class RequiredDataNotFoundException extends ApiException {
  constructor(message?: string) {
    super(message || 'Unable to find required data');
    this.name = 'RequiredDataNotFoundException';
    this.status = 400; // Bad Request
  }
}

export class NewSyncsForbiddenException extends ApiException {
  constructor(message?: string) {
    super(message || 'The service is not accepting new syncs');
    this.name = 'NewSyncsForbiddenException';
    this.status = 405; // Method Not Allowed
  }
}

export class NewSyncsLimitExceededException extends ApiException {
  constructor(message?: string) {
    super(message || 'Client has exceeded the daily new syncs limit');
    this.name = 'NewSyncsLimitExceededException';
    this.status = 406; // Not Acceptable
  }
}

export class NotImplementedException extends ApiException {
  constructor(message?: string) {
    super(message || 'The requested route has not been implemented');
    this.name = 'NotImplementedException';
    this.status = 404; // Not Found
  }
}

export class SyncConflictException extends ApiException {
  constructor(message?: string) {
    super(message || 'A sync conflict was detected');
    this.name = 'SyncConflictException';
    this.status = 409; // Conflict
  }
}

export class UnsupportedVersionException extends ApiException {
  constructor(message?: string) {
    super(message || 'The requested API version is not supported');
    this.name = 'UnsupportedVersionException';
    this.status = 412; // Precondition Failed
  }
}

export class SyncDataLimitExceededException extends ApiException {
  constructor(message?: string) {
    super(message || 'Sync data limit exceeded');
    this.name = 'SyncDataLimitExceededException';
    this.status = 413; // Payload Too Large
  }
}

export class RequestThrottledException extends ApiException {
  constructor(message?: string) {
    super(message || 'Too many requests');
    this.name = 'RequestThrottledException';
    this.status = 429; // Too Many Requests
  }
}

export class OriginNotPermittedException extends ApiException {
  constructor(message?: string) {
    super(message || 'Client not permitted to access this service');
    this.name = 'OriginNotPermittedException';
    this.status = 500; // Internal Server Error
  }
}

export class UnspecifiedException extends ApiException {
  constructor(message?: string) {
    super(message || 'An unspecified error has occurred');
    this.name = 'UnspecifiedException';
    this.status = 500; // Internal Server Error
  }
}

export class ServiceNotAvailableException extends ApiException {
  constructor(message?: string) {
    super(message || 'The service is currently offline');
    this.name = 'ServiceNotAvailableException';
    this.status = 503; // Service Unavailable
  }
}
</file>

<file path="src/location.spec.ts">
import 'jest';
import { getCountryNameFromLocationCode, setCountryNames, validateLocationCode } from './location';

describe('Location', () => {
  const invalidLocationCode = 'AA';

  it('getCountryNameFromLocationCode: should return null if no location code provided', () => {
    const countryName = getCountryNameFromLocationCode(null);
    expect(countryName).toBeNull();
  });

  it('getCountryNameFromLocationCode: should return undefined if location code is invalid', () => {
    const countryName = getCountryNameFromLocationCode(invalidLocationCode);
    expect(countryName).toBeUndefined();
  });

  it('getCountryNameFromLocationCode: should return correct country name for a valid location code', () => {
    const locationCode = 'GB';
    const countryName = getCountryNameFromLocationCode(locationCode);
    expect(countryName).toContain('United Kingdom');
  });

  it('setCountryNames: should update country names to the correct values', () => {
    const locationCode = 'GB';
    setCountryNames();
    const countryName = getCountryNameFromLocationCode(locationCode);
    expect(countryName).toBe('United Kingdom');
  });

  it('validateLocationCode: should return true if no location code provided', () => {
    const isValid = validateLocationCode(null);
    expect(isValid).toBe(true);
  });

  it('validateLocationCode: should return false if invalid location code provided', () => {
    const isValid = validateLocationCode(invalidLocationCode);
    expect(isValid).toBe(false);
  });

  it('validateLocationCode: should return true if valid location code provided', () => {
    const isValid = validateLocationCode('GB');
    expect(isValid).toBe(true);
  });
});
</file>

<file path="src/location.ts">
import { getName, overwrite } from 'country-list';

export const getCountryNameFromLocationCode = (locationCode: string): string => {
  if (!locationCode) {
    return null;
  }

  return getName(locationCode);
};

export const setCountryNames = (): void => {
  overwrite([
    {
      code: 'GB',
      name: 'United Kingdom',
    },
  ]);
};

export const validateLocationCode = (locationCode: string): boolean => {
  if (!locationCode) {
    return true;
  }

  const countryName = getName(locationCode);
  if (!countryName) {
    return false;
  }

  return true;
};
</file>

<file path="src/server.spec.ts">
import 'jest';
import bunyan from 'bunyan';
import cors from 'cors';
import express from 'express';
import fs from 'fs';
import http from 'http';
import https from 'https';
import mkdirp from 'mkdirp';
import { LogLevel } from './common/enums';
import * as Config from './config';
import * as DB from './db';
import {
  ApiException,
  OriginNotPermittedException,
  SyncDataLimitExceededException,
  UnspecifiedException,
} from './exception';
import * as Location from './location';
import { BookmarksRouter } from './routers/bookmarks.router';
import { DocsRouter } from './routers/docs.router';
import { InfoRouter } from './routers/info.router';
import * as Server from './server';

let corsConfig: cors.CorsOptions;
jest.mock('cors', () => {
  return jest.fn().mockImplementation((config: cors.CorsOptions) => {
    corsConfig = config;
  });
});

describe('Server', () => {
  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('cleanupServer: should close db connection', async () => {
    const disconnectSpy = jest.spyOn(DB, 'disconnect');
    await Server.cleanupServer({
      removeAllListeners: () => {},
    } as any);
    expect(disconnectSpy).toHaveBeenCalled();
  });

  it('createApplication: should create, configure and return a new express app', async () => {
    const initApplicationMock = jest.spyOn(Server, 'initApplication').mockImplementation();
    const initRoutesMock = jest.spyOn(Server, 'initRoutes').mockImplementation();
    const connectMock = jest.spyOn(DB, 'connect').mockImplementation();
    const app = await Server.createApplication();
    expect(app).not.toBeNull();
    expect(initApplicationMock).toHaveBeenCalledWith(app);
    expect(initRoutesMock).toHaveBeenCalledWith(app);
    expect(connectMock).toHaveBeenCalled();
  });

  it('createApplication: should exit process if an error is encountered', async () => {
    jest.spyOn(Server, 'initApplication').mockImplementation(() => {
      throw new Error();
    });
    const exitMock = jest.spyOn(process, 'exit').mockImplementation();
    await Server.createApplication();
    expect(exitMock).toHaveBeenCalledWith(1);
  });

  it('createLogger: should create a bunyan logger with the provided streams', async () => {
    const createLoggerSpy = jest.spyOn(bunyan, 'createLogger').mockImplementation();
    const streamsTest = [];
    Server.createLogger(streamsTest);
    expect(createLoggerSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        streams: streamsTest,
      })
    );
  });

  it('createLogger: should output error message to console if bunyan.createLogger throws an error', async () => {
    jest.spyOn(bunyan, 'createLogger').mockImplementation(() => {
      throw new Error();
    });
    const errorMock = jest.spyOn(console, 'error').mockImplementation();
    expect(() => {
      Server.createLogger([]);
    }).toThrowError();
    expect(errorMock).toHaveBeenCalled();
  });

  it('initApplication: should enable logging to stdout if specified in config settings', () => {
    const logLevelTest = 'debug';
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [],
      log: {
        file: {
          enabled: false,
        },
        stdout: {
          enabled: true,
          level: logLevelTest,
        },
      },
      server: {
        behindProxy: false,
      },
      throttle: {
        maxRequests: 0,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const createLoggerMock = jest.spyOn(Server, 'createLogger');
    const app: any = {
      enable: jest.fn(),
      options: jest.fn(),
      use: jest.fn(),
    };
    Server.initApplication(app);
    expect(createLoggerMock).toBeCalledWith([
      {
        level: logLevelTest,
        stream: process.stdout,
      },
    ]);
  });

  it('initApplication: should enable logging to file if specified in config settings', () => {
    const logLevelTest = 'debug';
    const logPathTest = '/var/log/xbs/api.log';
    const logRotatedFilesToKeepTest = 1;
    const logRotationPeriodTest = '1w';
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [],
      log: {
        file: {
          enabled: true,
          level: logLevelTest,
          path: logPathTest,
          rotatedFilesToKeep: logRotatedFilesToKeepTest,
          rotationPeriod: logRotationPeriodTest,
        },
        stdout: {
          enabled: false,
        },
      },
      server: {
        behindProxy: false,
      },
      throttle: {
        maxRequests: 0,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(fs, 'existsSync').mockReturnValue(true);
    const createLoggerMock = jest.spyOn(Server, 'createLogger').mockImplementation();
    const app: any = {
      enable: jest.fn(),
      options: jest.fn(),
      use: jest.fn(),
    };
    Server.initApplication(app);
    expect(createLoggerMock).toBeCalledWith([
      {
        count: logRotatedFilesToKeepTest,
        level: logLevelTest,
        path: logPathTest,
        period: logRotationPeriodTest,
        type: 'rotating-file',
      },
    ]);
  });

  it('initApplication: should create a directory for the log file if not exists and file log enabled in config settings', () => {
    const logLevelTest = 'debug';
    const logPathDirTest = '/var/log/xbs';
    const logPathTest = '/var/log/xbs/api.log';
    const logRotatedFilesToKeepTest = 1;
    const logRotationPeriodTest = '1w';
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [],
      log: {
        file: {
          enabled: true,
          level: logLevelTest,
          path: logPathTest,
          rotatedFilesToKeep: logRotatedFilesToKeepTest,
          rotationPeriod: logRotationPeriodTest,
        },
        stdout: {
          enabled: false,
        },
      },
      server: {
        behindProxy: false,
      },
      throttle: {
        maxRequests: 0,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(fs, 'existsSync').mockReturnValue(false);
    const syncMock = jest.spyOn(mkdirp, 'sync').mockImplementation();
    jest.spyOn(Server, 'createLogger').mockImplementation();
    const app: any = {
      enable: jest.fn(),
      options: jest.fn(),
      use: jest.fn(),
    };
    Server.initApplication(app);
    expect(syncMock).toBeCalledWith(logPathDirTest);
  });

  it('initApplication: should throw an error if file path not specified and file log enabled in config settings', () => {
    const logLevelTest = 'debug';
    const logRotatedFilesToKeepTest = 1;
    const logRotationPeriodTest = '1w';
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [],
      log: {
        file: {
          enabled: true,
          level: logLevelTest,
          rotatedFilesToKeep: logRotatedFilesToKeepTest,
          rotationPeriod: logRotationPeriodTest,
        },
        stdout: {
          enabled: false,
        },
      },
      server: {
        behindProxy: false,
      },
      throttle: {
        maxRequests: 0,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(console, 'error').mockImplementation();
    const app: any = {
      enable: jest.fn(),
      options: jest.fn(),
      use: jest.fn(),
    };
    expect(() => {
      Server.initApplication(app);
    }).toThrowError();
  });

  it('initApplication: should limit size of json encoded request bodies by default to 512000', () => {
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [],
      log: {
        file: {
          enabled: false,
        },
        stdout: {
          enabled: false,
        },
      },
      server: {
        behindProxy: false,
      },
      throttle: {
        maxRequests: 0,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const jsonMock = jest.spyOn(express, 'json').mockImplementation();
    const useMock = jest.fn().mockImplementation((callback) => {
      try {
        callback();
      } catch {}
    });
    const app: any = {
      enable: jest.fn(),
      options: jest.fn(),
      use: useMock,
    };
    Server.initApplication(app);
    expect(jsonMock).toHaveBeenCalledWith({
      limit: 512000,
    });
  });

  it('initApplication: should limit size of json encoded request bodies to maxSyncSize defined in config settings', () => {
    const maxSyncSizeTest = 999999;
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [],
      log: {
        file: {
          enabled: false,
        },
        stdout: {
          enabled: false,
        },
      },
      maxSyncSize: maxSyncSizeTest,
      server: {
        behindProxy: false,
      },
      throttle: {
        maxRequests: 0,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const jsonMock = jest.spyOn(express, 'json').mockImplementation();
    const useMock = jest.fn().mockImplementation((callback) => {
      try {
        callback();
      } catch {}
    });
    const app: any = {
      enable: jest.fn(),
      options: jest.fn(),
      use: useMock,
    };
    Server.initApplication(app);
    expect(jsonMock).toHaveBeenCalledWith({
      limit: maxSyncSizeTest,
    });
  });

  it('initApplication: should configure cors with undefined if no origins set in config settings', () => {
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [],
      log: {
        file: {
          enabled: false,
        },
        stdout: {
          enabled: false,
        },
      },
      server: {
        behindProxy: false,
      },
      throttle: {
        maxRequests: 0,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const useMock = jest.fn().mockImplementation((callback) => {
      try {
        callback();
      } catch {}
    });
    const app: any = {
      enable: jest.fn(),
      options: jest.fn(),
      use: useMock,
    };
    Server.initApplication(app);
    expect(corsConfig).toBeUndefined();
  });

  it('initApplication: should throw OriginNotPermittedException exception if origin not present in allowedOrigins defined in config settings', () => {
    const originTest = 'http://www.allowed-origin.com';
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [originTest],
      log: {
        file: {
          enabled: false,
        },
        stdout: {
          enabled: false,
        },
      },
      server: {
        behindProxy: false,
      },
      throttle: {
        maxRequests: 0,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const useMock = jest.fn().mockImplementation((callback) => {
      try {
        callback();
      } catch {}
    });
    const app: any = {
      enable: jest.fn(),
      options: jest.fn(),
      use: useMock,
    };
    Server.initApplication(app);
    let originErr: Error;
    try {
      (corsConfig.origin as any)('http://www.forbidden-origin.com', (err: Error) => {
        originErr = err;
      });
    } catch {}
    expect(corsConfig).toStrictEqual({
      origin: expect.any(Function),
    });
    expect(() => {
      throw originErr;
    }).toThrow(OriginNotPermittedException);
  });

  it('initApplication: should allow origin if present in allowedOrigins defined in config settings', () => {
    const originTest = 'http://www.allowed-origin.com';
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [originTest],
      log: {
        file: {
          enabled: false,
        },
        stdout: {
          enabled: false,
        },
      },
      server: {
        behindProxy: false,
      },
      throttle: {
        maxRequests: 0,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const useMock = jest.fn().mockImplementation((callback) => {
      try {
        callback();
      } catch {}
    });
    const app: any = {
      enable: jest.fn(),
      options: jest.fn(),
      use: useMock,
    };
    Server.initApplication(app);
    const originCallbackMock = jest.fn();
    try {
      (corsConfig.origin as any)(originTest, originCallbackMock);
    } catch {}
    expect(corsConfig).toStrictEqual({
      origin: expect.any(Function),
    });
    expect(originCallbackMock).toBeCalledWith(null, true);
  });

  it('initApplication: should add noCache to application', () => {
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [],
      log: {
        file: {
          enabled: false,
        },
        stdout: {
          enabled: false,
        },
      },
      server: {
        behindProxy: false,
      },
      throttle: {
        maxRequests: 0,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const useMock = jest.fn().mockImplementation((callback) => {
      try {
        expect(callback.name).toBe('noCache');
      } catch {}
    });
    const app: any = {
      enable: jest.fn(),
      options: jest.fn(),
      use: useMock,
    };
    Server.initApplication(app);
  });

  it('initApplication: should add existing version specified in request headers to request headers', () => {
    const versionTest = '9.9.9';
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [],
      log: {
        file: {
          enabled: false,
        },
        stdout: {
          enabled: false,
        },
      },
      server: {
        behindProxy: false,
      },
      throttle: {
        maxRequests: 0,
      },
      version: '1.0.0',
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const req: any = {
      headers: {
        'accept-version': versionTest,
      },
    };
    const nextMock = jest.fn();
    const useMock = jest.fn().mockImplementation((callback) => {
      try {
        callback(req, null, nextMock);
        expect(req.version).toStrictEqual(versionTest);
      } catch {}
    });
    const app: any = {
      enable: jest.fn(),
      options: jest.fn(),
      use: useMock,
    };
    Server.initApplication(app);
  });

  it('initApplication: should add api version specified in config settings to request headers', () => {
    const versionTest = '9.9.9';
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [],
      log: {
        file: {
          enabled: false,
        },
        stdout: {
          enabled: false,
        },
      },
      server: {
        behindProxy: false,
      },
      throttle: {
        maxRequests: 0,
      },
      version: versionTest,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const req: any = {
      headers: [],
    };
    const nextMock = jest.fn();
    const useMock = jest.fn().mockImplementation((callback) => {
      try {
        callback(req, null, nextMock);
        expect(req.version).toStrictEqual(versionTest);
      } catch {}
    });
    const app: any = {
      enable: jest.fn(),
      options: jest.fn(),
      use: useMock,
    };
    Server.initApplication(app);
  });

  it('initApplication: should enable trust proxy if behindProxy enabled in config settings', () => {
    const configSettingsTest: Config.IConfigSettings = {
      allowedOrigins: [],
      log: {
        file: {
          enabled: false,
        },
        stdout: {
          enabled: false,
        },
      },
      server: {
        behindProxy: true,
      },
      throttle: {
        maxRequests: 0,
      },
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const enableMock = jest.fn();
    const app: any = {
      enable: enableMock,
      options: jest.fn(),
      use: jest.fn(),
    };
    Server.initApplication(app);
    expect(enableMock).toHaveBeenCalledWith('trust proxy');
  });

  it('handleError: should set response status code to 500 if no status code provided', async () => {
    const statusMock = jest.fn();
    const req: any = {
      accepts: jest.fn,
    };
    const res: any = {
      json: () => {},
      status: statusMock,
    };
    Server.handleError(new Error(), req, res, jest.fn);
    expect(statusMock).toHaveBeenCalledWith(500);
  });

  it('handleError: should set response status code to status code provided', async () => {
    const statusTest = 999;
    const exception = new ApiException('');
    exception.status = statusTest;
    const statusMock = jest.fn();
    const req: any = {
      accepts: jest.fn,
    };
    const res: any = {
      json: () => {},
      status: statusMock,
    };
    Server.handleError(exception, req, res, jest.fn);
    expect(statusMock).toHaveBeenCalledWith(statusTest);
  });

  it('handleError: should set response json to with provided error response object', async () => {
    const message = 'test';
    const exception = new ApiException(message);
    const jsonMock = jest.fn();
    const req: any = {
      accepts: jest.fn,
    };
    const res: any = {
      json: jsonMock,
      status: () => {},
    };
    Server.handleError(exception, req, res, jest.fn);
    expect(jsonMock).toHaveBeenCalledWith(exception.getResponseObject());
  });

  it('handleError: should set response json to SyncDataLimitExceededException response object if provided error status code is 413', async () => {
    const exception = new Error();
    (exception as any).status = 413;
    const jsonMock = jest.fn();
    const req: any = {
      accepts: jest.fn,
    };
    const res: any = {
      json: jsonMock,
      status: () => {},
    };
    Server.handleError(exception, req, res, jest.fn);
    expect(jsonMock).toHaveBeenCalledWith(new SyncDataLimitExceededException().getResponseObject());
  });

  it('handleError: should set response json to UnspecifiedException response object if provided error is not an instance of ExceptionBase', async () => {
    const jsonMock = jest.fn();
    const req: any = {
      accepts: jest.fn,
    };
    const res: any = {
      json: jsonMock,
      status: jest.fn,
    };
    Server.handleError(new Error(), req, res, jest.fn);
    expect(jsonMock).toHaveBeenCalledWith(new UnspecifiedException().getResponseObject());
  });

  it('initRoutes: should initialise docs routes', async () => {
    const initDocsRouterRoutesMock = jest.spyOn(DocsRouter.prototype, 'initRoutes').mockImplementation();
    const app: any = {
      get: jest.fn(),
      use: jest.fn(),
    };
    Server.initRoutes(app);
    expect(initDocsRouterRoutesMock).toHaveBeenCalled();
  });

  it('initRoutes: should initialise bookmarks routes', async () => {
    const initBookmarksRouterRoutesMock = jest.spyOn(BookmarksRouter.prototype, 'initRoutes').mockImplementation();
    const app: any = {
      get: jest.fn(),
      use: jest.fn(),
    };
    Server.initRoutes(app);
    expect(initBookmarksRouterRoutesMock).toHaveBeenCalled();
  });

  it('initRoutes: should initialise info routes', async () => {
    const initInfoRouterRoutesMock = jest.spyOn(InfoRouter.prototype, 'initRoutes').mockImplementation();
    const app: any = {
      get: jest.fn(),
      use: jest.fn(),
    };
    Server.initRoutes(app);
    expect(initInfoRouterRoutesMock).toHaveBeenCalled();
  });

  it('logMessage: should call logger.error when log level is error', async () => {
    const errorTest = new Error();
    const reqTest = {};
    const formatTest = {
      err: errorTest,
      req: reqTest,
    };
    const messageTest = 'test message';
    const errorMock = jest.fn();
    jest.spyOn(bunyan, 'createLogger').mockImplementation(() => {
      return {
        error: errorMock,
      } as any;
    });
    Server.createLogger([]);
    Server.logMessage(LogLevel.Error, messageTest, reqTest as any, errorTest);
    expect(errorMock).toHaveBeenCalledWith(expect.objectContaining(formatTest), messageTest);
  });

  it('logMessage: should call logger.info when log level is info', async () => {
    const reqTest = {};
    const formatTest = {
      req: reqTest,
    };
    const messageTest = 'test message';
    const infoMock = jest.fn();
    jest.spyOn(bunyan, 'createLogger').mockImplementation(() => {
      return {
        info: infoMock,
      } as any;
    });
    Server.createLogger([]);
    Server.logMessage(LogLevel.Info, messageTest, reqTest as any);
    expect(infoMock).toHaveBeenCalledWith(expect.objectContaining(formatTest), messageTest);
  });

  it('startService: should exit if an invalid location code is used in config settings', async () => {
    const locationTest = 'locationTest';
    const configSettingsTest: Config.IConfigSettings = {
      location: locationTest,
    };
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const validateLocationCodeMock = jest.spyOn(Location, 'validateLocationCode').mockReturnValue(false);
    jest.spyOn(Server, 'logMessage').mockImplementation();
    const exitMock = jest.spyOn(process, 'exit').mockImplementation();
    await Server.startService({} as any);
    expect(validateLocationCodeMock).toHaveBeenCalledWith(locationTest);
    expect(exitMock).toHaveBeenCalled();
  });

  it('startService: should create an http server by default', async () => {
    const portTest = 12345;
    const configSettingsTest: Config.IConfigSettings = {
      server: {
        https: {
          enabled: false,
        },
        port: portTest,
      },
    };
    jest.spyOn(Location, 'validateLocationCode').mockReturnValue(true);
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(fs, 'readFileSync').mockImplementation((x) => x as any);
    jest.spyOn(process, 'on').mockImplementation();
    const listenMockReturnValue = {
      on: jest.fn(),
    };
    const listenMock = jest.fn().mockReturnValue(listenMockReturnValue);
    const createServerMock = jest.spyOn(http, 'createServer').mockReturnValue({
      listen: listenMock,
    } as any);
    const app = {} as any;
    const server = await Server.startService(app);
    expect(createServerMock).toHaveBeenCalledWith(app);
    expect(listenMock).toHaveBeenCalledWith(portTest, null, expect.anything());
    expect(server).toBe(listenMockReturnValue);
  });

  it('startService: should create an https server if specified in config settings', async () => {
    const certPathTest = 'certPathTest';
    const keyPathTest = 'keyPathTest';
    const portTest = 12345;
    const configSettingsTest: Config.IConfigSettings = {
      server: {
        https: {
          certPath: certPathTest,
          enabled: true,
          keyPath: keyPathTest,
        },
        port: portTest,
      },
    };
    jest.spyOn(Location, 'validateLocationCode').mockReturnValue(true);
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    jest.spyOn(fs, 'readFileSync').mockImplementation((x) => x as any);
    jest.spyOn(process, 'on').mockImplementation();
    const listenMockReturnValue = {
      on: jest.fn(),
    };
    const listenMock = jest.fn().mockReturnValue(listenMockReturnValue);
    const createServerMock = jest.spyOn(https, 'createServer').mockReturnValue({
      listen: listenMock,
    } as any);
    const optionsTest: https.ServerOptions = {
      cert: certPathTest,
      key: keyPathTest,
    };
    const app = {} as any;
    const server = await Server.startService(app);
    expect(createServerMock).toHaveBeenCalledWith(optionsTest, app);
    expect(listenMock).toHaveBeenCalledWith(portTest, null, expect.anything());
    expect(server).toBe(listenMockReturnValue);
  });

  it('startService: should stop server on SIGINT event', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      server: {
        https: {
          enabled: false,
        },
      },
    };
    jest.spyOn(Location, 'validateLocationCode').mockReturnValue(true);
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const serverTest: any = {
      close: async (callback): Promise<any> => {
        await callback();
      },
    };
    jest.spyOn(http, 'createServer').mockReturnValue({
      listen: jest.fn().mockReturnValue(serverTest),
    } as any);
    jest.spyOn(process, 'on').mockImplementation((event: string | symbol, callback): any => {
      if (event === 'SIGINT') {
        callback(null, null, null);
      }
    });
    const cleanupServerMock = jest.spyOn(Server, 'cleanupServer').mockImplementation(() => {
      return Promise.resolve();
    });
    const exitMock = jest.spyOn(process, 'exit').mockImplementation();
    await Server.startService({} as any);
    expect(cleanupServerMock).toHaveBeenCalledWith(serverTest);
    expect(exitMock).toHaveBeenCalledWith(0);
  });

  it('startService: should stop server on SIGUSR1 event', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      server: {
        https: {
          enabled: false,
        },
      },
    };
    jest.spyOn(Location, 'validateLocationCode').mockReturnValue(true);
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const serverTest: any = {
      close: async (callback): Promise<any> => {
        await callback();
      },
    };
    jest.spyOn(http, 'createServer').mockReturnValue({
      listen: jest.fn().mockReturnValue(serverTest),
    } as any);
    jest.spyOn(process, 'on').mockImplementation((event: string | symbol, callback): any => {
      if (event === 'SIGUSR1') {
        callback(null, null, null);
      }
    });
    const cleanupServerMock = jest.spyOn(Server, 'cleanupServer').mockImplementation(() => {
      return Promise.resolve();
    });
    const exitMock = jest.spyOn(process, 'exit').mockImplementation();
    await Server.startService({} as any);
    expect(cleanupServerMock).toHaveBeenCalledWith(serverTest);
    expect(exitMock).toHaveBeenCalledWith(0);
  });

  it('startService: should stop server on SIGUSR2 event', async () => {
    const configSettingsTest: Config.IConfigSettings = {
      server: {
        https: {
          enabled: false,
        },
      },
    };
    jest.spyOn(Location, 'validateLocationCode').mockReturnValue(true);
    jest.spyOn(Config, 'get').mockReturnValue(configSettingsTest);
    const serverTest: any = {
      close: async (callback): Promise<any> => {
        await callback();
      },
    };
    jest.spyOn(http, 'createServer').mockReturnValue({
      listen: jest.fn().mockReturnValue(serverTest),
    } as any);
    jest.spyOn(process, 'on').mockImplementation((event: string | symbol, callback): any => {
      if (event === 'SIGUSR2') {
        callback(null, null, null);
      }
    });
    const cleanupServerMock = jest.spyOn(Server, 'cleanupServer').mockImplementation(() => {
      return Promise.resolve();
    });
    const exitMock = jest.spyOn(process, 'exit').mockImplementation();
    await Server.startService({} as any);
    expect(cleanupServerMock).toHaveBeenCalledWith(serverTest);
    expect(exitMock).toHaveBeenCalledWith(0);
  });

  it('stopService: should close the provided server', async () => {
    const closeMock = jest.fn(async (callback: () => Promise<void>) => {
      await callback();
    });
    const serverTest: any = {
      close: closeMock,
    };
    const cleanupServerMock = jest.spyOn(Server, 'cleanupServer').mockResolvedValue();
    await Server.stopService(serverTest);
    expect(closeMock).toHaveBeenCalled();
    expect(cleanupServerMock).toHaveBeenCalledWith(serverTest);
  });
});
</file>

<file path="src/server.ts">
import bunyan from 'bunyan';
import cors from 'cors';
import express from 'express';
import rateLimit from 'express-rate-limit';
import fs from 'fs';
import helmet from 'helmet';
import http from 'http';
import https from 'https';
import mkdirp from 'mkdirp';
import noCache from 'nocache';
import { LogLevel } from './common/enums';
import * as Config from './config';
import * as DB from './db';
import {
  ApiException,
  NotImplementedException,
  OriginNotPermittedException,
  RequestThrottledException,
  SyncDataLimitExceededException,
  UnspecifiedException,
} from './exception';
import * as Location from './location';
import { BookmarksRouter } from './routers/bookmarks.router';
import { DocsRouter } from './routers/docs.router';
import { InfoRouter } from './routers/info.router';
import { BookmarksService } from './services/bookmarks.service';
import { InfoService } from './services/info.service';
import { NewSyncLogsService } from './services/newSyncLogs.service';

let logger: bunyan;

// Cleans up server connections when stopping the service
export const cleanupServer = async (server: http.Server | https.Server): Promise<void> => {
  logMessage(LogLevel.Info, `Service shutting down`);
  await DB.disconnect();
  server.removeAllListeners();
  process.removeAllListeners();
};

// Creates a new express application, configures routes and connects to the database
export const createApplication = async (): Promise<express.Express> => {
  const app = express();

  try {
    initApplication(app);
    initRoutes(app);
    app.use(handleError);

    // Establish database connection
    await DB.connect(logMessage);
  } catch (err) {
    logMessage(LogLevel.Error, `Couldn't create application`, null, err);
    return process.exit(1);
  }

  return app;
};

// Creates a new bunyan logger for the module
export const createLogger = (logStreams: bunyan.Stream[]): void => {
  try {
    logger = bunyan.createLogger({
      name: 'xBrowserSync_api',
      serializers: bunyan.stdSerializers,
      streams: logStreams,
    });
  } catch (err) {
    // eslint-disable-next-line no-console
    console.error(`Failed to initialise logger.`);
    throw err;
  }
};

// Handles and logs api errors
export const handleError = (
  err: any,
  req: express.Request,
  res: express.Response,
  next: express.NextFunction
): void => {
  if (res.headersSent) {
    return next(err);
  }

  // Determine the response value based on the error thrown
  let responseObj: any;
  switch (true) {
    // If the error is one of our exceptions get the reponse object to return to the client
    case err instanceof ApiException:
      responseObj = (err as ApiException).getResponseObject();
      break;
    // If the error is 413 Request Entity Too Large return a SyncDataLimitExceededException
    case err.status === 413:
      err = new SyncDataLimitExceededException();
      responseObj = (err as SyncDataLimitExceededException).getResponseObject();
      break;
    // Otherwise return an UnspecifiedException
    default:
      err = new UnspecifiedException();
      responseObj = (err as UnspecifiedException).getResponseObject();
  }

  res.status(err.status || 500);
  if (req.accepts('json')) {
    res.json(responseObj);
    return;
  }
  next(responseObj);
};

// Initialises the express application and middleware
export const initApplication = (app: express.Express): void => {
  const logStreams = [];

  // Enabled logging to stdout if required
  if (Config.get().log.stdout.enabled) {
    // Add file log stream
    logStreams.push({
      level: Config.get().log.stdout.level,
      stream: process.stdout,
    });
  }

  // Enable logging to file if required
  if (Config.get().log.file.enabled) {
    try {
      // Ensure log directory exists
      const logDirectory = Config.get().log.file.path.substring(0, Config.get().log.file.path.lastIndexOf('/'));
      if (!fs.existsSync(logDirectory)) {
        mkdirp.sync(logDirectory);
      }

      // Add file log stream
      logStreams.push({
        count: Config.get().log.file.rotatedFilesToKeep,
        level: Config.get().log.file.level,
        path: Config.get().log.file.path,
        period: Config.get().log.file.rotationPeriod,
        type: 'rotating-file',
      });
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error(`Failed to initialise log file.`);
      throw err;
    }
  }

  if (logStreams.length > 0) {
    // Initialise bunyan logger
    createLogger(logStreams);
  }

  // Create helmet config for security hardening
  app.use(helmet());
  app.use(noCache());

  // Add default version to request if not supplied
  app.use((req: any, res: express.Response, next: express.NextFunction) => {
    req.version = req.headers['accept-version'] || Config.get().version;
    next();
  });

  // If behind proxy use 'X-Forwarded-For' header for client ip address
  if (Config.get().server.behindProxy) {
    app.enable('trust proxy');
  }

  // Process JSON-encoded bodies, set body size limit to config value or default to 500kb
  app.use(
    express.json({
      limit: Config.get().maxSyncSize || 512000,
    })
  );

  // Enable support for CORS
  const corsOptions: cors.CorsOptions =
    Config.get().allowedOrigins.length > 0
      ? {
          origin: (origin, callback) => {
            if (Config.get().allowedOrigins.indexOf(origin) !== -1) {
              callback(null, true);
            } else {
              const err = new OriginNotPermittedException();
              callback(err);
            }
          },
        }
      : undefined;
  app.use(cors(corsOptions));

  // Add thottling if enabled
  if (Config.get().throttle.maxRequests > 0) {
    app.use(
      rateLimit({
        handler: (req, res, next) => {
          next(new RequestThrottledException());
        },
        max: Config.get().throttle.maxRequests,
        windowMs: Config.get().throttle.timeWindow,
      })
    );
  }
};

// Configures api routing
export const initRoutes = (app: express.Express): void => {
  const router = express.Router();
  app.use(Config.get().server.relativePath, router);

  // Initialise services
  const newSyncLogsService = new NewSyncLogsService(null, logMessage);
  const bookmarksService = new BookmarksService(newSyncLogsService, logMessage);
  const infoService = new InfoService(bookmarksService, logMessage);

  // Initialise routes
  const docsRouter = new DocsRouter(app);
  const bookmarkRouter = new BookmarksRouter(app, bookmarksService);
  const infoRouter = new InfoRouter(app, infoService);

  // Handle all other routes with 404 error
  app.use((req, res, next) => {
    const err = new NotImplementedException();
    next(err);
  });
};

// Logs messages and errors to console and to file (if enabled)
export const logMessage = (level: LogLevel, message: string, req?: express.Request, err?: Error): void => {
  if (!logger) {
    return;
  }

  switch (level) {
    case LogLevel.Error:
      logger.error({ req, err }, message);
      break;
    case LogLevel.Info:
    default:
      logger.info({ req }, message);
      break;
  }
};

// Starts the api service
export const startService = async (app: express.Application): Promise<http.Server | https.Server> => {
  // Check if location is valid before starting
  if (!Location.validateLocationCode(Config.get().location)) {
    logMessage(LogLevel.Error, `Location is not a valid country code, exiting`);
    return process.exit(1);
  }

  // Create https server if enabled in config, otherwise create http server
  let server: http.Server | https.Server;
  const serverListening = () => {
    const protocol = Config.get().server.https.enabled ? 'https' : 'http';
    const url = `${protocol}://${Config.get().server.host}:${Config.get().server.port}${
      Config.get().server.relativePath
    }`;
    logMessage(LogLevel.Info, `Service started at ${url}`);
  };
  if (Config.get().server.https.enabled) {
    const options: https.ServerOptions = {
      cert: fs.readFileSync(Config.get().server.https.certPath),
      key: fs.readFileSync(Config.get().server.https.keyPath),
    };
    server = https.createServer(options, app).listen(Config.get().server.port, null, serverListening);
  } else {
    server = http.createServer(app).listen(Config.get().server.port, null, serverListening);
  }

  // Catches ctrl+c event
  process.on('SIGINT', () => {
    logMessage(LogLevel.Info, `Process terminated by SIGINT`, null, null);
    server.close(async () => {
      await cleanupServer(server);
      return process.exit(0);
    });
  });

  // Catches kill pid event
  process.on('SIGUSR1', () => {
    logMessage(LogLevel.Info, `Process terminated by SIGUSR1`, null, null);
    server.close(async () => {
      await cleanupServer(server);
      return process.exit(0);
    });
  });

  // Catches kill pid event
  process.on('SIGUSR2', () => {
    logMessage(LogLevel.Info, `Process terminated by SIGUSR2`, null, null);
    server.close(async () => {
      await cleanupServer(server);
      return process.exit(0);
    });
  });

  return server;
};

// Stops the api service
export const stopService = (server: http.Server | https.Server): Promise<void> => {
  return new Promise((resolve) => {
    server.close(async () => {
      await cleanupServer(server);
      resolve();
    });
  });
};
</file>

<file path="src/uuid.spec.ts">
import 'jest';
import { InvalidArgumentException, InvalidSyncIdException } from './exception';
import { convertBytesToUuidString, convertUuidStringToBinary, generateRandomUuid } from './uuid';

describe('UUID', () => {
  const testBytes = [52, 78, 238, 253, 60, 131, 78, 102, 155, 226, 241, 12, 69, 188, 89, 110];
  const testUuid = '344eeefd3c834e669be2f10c45bc596e';

  it('convertBytesToUuidString: should return a UUID from a given set of bytes', () => {
    const buffer = Buffer.from(testBytes);
    const uuid = convertBytesToUuidString(buffer);
    expect(typeof uuid).toBe('string');
    expect(uuid).not.toBeFalsy();
    expect(uuid).toStrictEqual(testUuid);
  });

  it('convertBytesToUuidString: should return null if supplied param is null', () => {
    const uuid = convertBytesToUuidString(null);
    expect(uuid).toBeNull();
  });

  it('convertBytesToUuidString: should throw InvalidArgumentException if supplied param is not a byte array', () => {
    expect(() => {
      convertBytesToUuidString('Not a byte array' as any);
    }).toThrow(InvalidArgumentException);
  });

  it('convertBytesToUuidString: should throw InvalidArgumentException if supplied byte array is wrong size', () => {
    expect(() => {
      const buffer = Buffer.from(testBytes.concat(testBytes));
      convertBytesToUuidString(buffer);
    }).toThrow(InvalidArgumentException);
  });

  it('convertUuidStringToBinary: should return a binary UUID from a given UUID string', () => {
    const binary = convertUuidStringToBinary(testUuid);
    expect(binary).not.toBeNull();
    expect(binary.buffer).toStrictEqual(Buffer.from(testBytes));
  });

  it('convertUuidStringToBinary: should return a version 4 binary UUID', () => {
    const binary = convertUuidStringToBinary(testUuid);
    expect(binary.sub_type).toBe(4);
  });

  it('convertUuidStringToBinary: should return null if supplied param is null', () => {
    const binary = convertUuidStringToBinary(null);
    expect(binary).toBeNull();
  });

  it('convertUuidStringToBinary: should throw InvalidArgumentException if supplied param is not a string', () => {
    expect(() => {
      convertUuidStringToBinary(1 as any);
    }).toThrow(InvalidArgumentException);
  });

  it('convertUuidStringToBinary: should throw InvalidSyncIdException if supplied param is not a valid UUID string', () => {
    expect(() => {
      convertUuidStringToBinary('Not a valid UUID string');
    }).toThrow(InvalidSyncIdException);
  });

  it('generateRandomUuid: should return a binary UUID with 16 bytes', () => {
    const binary = generateRandomUuid();
    expect(binary.buffer.length).toBe(16);
  });

  it('generateRandomUuid: should return a version 4 binary UUID', () => {
    const binary = generateRandomUuid();
    expect(binary.sub_type).toBe(4);
  });
});
</file>

<file path="src/uuid.ts">
import { Binary } from 'mongodb';
import mongoose from 'mongoose';
import * as uuid from 'uuid';
import uuidParse from 'uuid-parse';
import { InvalidArgumentException, InvalidSyncIdException } from './exception';

export const convertBytesToUuidString = (bytes: Buffer): string => {
  if (!bytes) {
    return null;
  }

  if (!Buffer.isBuffer(bytes)) {
    throw new InvalidArgumentException();
  }

  if (bytes.length !== 16) {
    throw new InvalidArgumentException('Byte array not of the expected size');
  }

  return uuidParse.unparse(bytes).replace(/-/g, '');
};

export const convertUuidStringToBinary = (uuidString: string): Binary => {
  if (!uuidString) {
    return null;
  }

  if (typeof uuidString !== 'string') {
    throw new InvalidArgumentException();
  }

  let binary: Binary;
  try {
    const buffer = uuidParse.parse(uuidString);
    binary = new mongoose.Types.Buffer(buffer).toObject(0x04);
    if (convertBytesToUuidString(binary.buffer) !== uuidString.replace(/-/g, '')) {
      throw new Error();
    }
  } catch (err) {
    throw new InvalidSyncIdException('Argument is not a valid UUID string');
  }

  return binary;
};

export const generateRandomUuid = (): Binary => {
  const buffer = uuid.v4(null, Buffer.alloc(16));
  return new mongoose.Types.Buffer(buffer).toObject(0x04);
};
</file>

<file path="test/e2e/bookmarks.spec.ts">
import 'jest';
import express from 'express';
import http from 'http';
import https from 'https';
import request from 'supertest';
import * as Config from '../../src/config';
import { BookmarksModel } from '../../src/models/bookmarks.model';
import { NewSyncLogsModel } from '../../src/models/newSyncLogs.model';
import * as Server from '../../src/server';

describe('BookmarksRouter', () => {
  const bookmarksDataTestVal = `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`;
  const syncVersionTestVal = '1.1.3';
  const syncIdTestVal = '426e20b680054872a46c3e1ce9a2c54e';
  let app: express.Express;
  let service: http.Server | https.Server;
  let testConfig: Config.IConfigSettings;

  beforeEach(async () => {
    testConfig = Config.get(true);
    testConfig.log.file.enabled = false;
    testConfig.log.stdout.enabled = false;
    testConfig.db.name = testConfig.tests.db;
    testConfig.server.port = testConfig.tests.port;
    app = await Server.createApplication();
    service = await Server.startService(app);
  });

  afterEach(async () => {
    jest.restoreAllMocks();
    await BookmarksModel.deleteMany({}).exec();
    await NewSyncLogsModel.deleteMany({}).exec();
    await Server.stopService(service);
  });

  it('POST /bookmarks should return a 405 status code if new syncs are not allowed', async () => {
    testConfig.status.allowNewSyncs = false;
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const data = {
      version: syncVersionTestVal,
    };
    const response = await request(app)
      .post(`${Config.get().server.relativePath}bookmarks`)
      .set('content-type', 'application/json')
      .send(data);
    expect(response.status).toBe(405);
  });

  it('POST /bookmarks should return a 406 status code if daily syncs limit exceeded', async () => {
    testConfig.dailyNewSyncsLimit = 1;
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const data = {
      version: syncVersionTestVal,
    };
    let response = await request(app)
      .post(`${Config.get().server.relativePath}bookmarks`)
      .set('content-type', 'application/json')
      .send(data);
    expect(response.status).toBe(200);
    response = await request(app)
      .post(`${Config.get().server.relativePath}bookmarks`)
      .set('content-type', 'application/json')
      .send(data);
    expect(response.status).toBe(406);
  });

  it('POST /bookmarks should return a 503 status code if service offline', async () => {
    await Server.stopService(service);
    testConfig.status.online = false;
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    app = await Server.createApplication();
    service = await Server.startService(app);
    const data = {
      version: syncVersionTestVal,
    };
    const response = await request(app)
      .post(`${Config.get().server.relativePath}bookmarks`)
      .set('content-type', 'application/json')
      .send(data);
    expect(response.status).toBe(503);
  });

  it('POST /bookmarks should return a 200 status code code and bookmarks sync data', async () => {
    testConfig.dailyNewSyncsLimit = 0;
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const response = await request(app)
      .post(`${Config.get().server.relativePath}bookmarks`)
      .set('content-type', 'application/json')
      .send({ version: syncVersionTestVal });
    expect(response.status).toBe(200);
    expect(response.type).toBe('application/json');
    expect(typeof response.body.id).toBe('string');
    expect(Date.parse(response.body.lastUpdated)).not.toBeNaN();
    expect(response.body.version).toStrictEqual(syncVersionTestVal);
  });

  it('PUT /bookmarks/:id should return a 413 status code when bookmarks data size exceeds Server limit', async () => {
    await Server.stopService(service);
    testConfig.maxSyncSize = 1;
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    app = await Server.createApplication();
    service = await Server.startService(app);
    const response = await request(app)
      .put(`${Config.get().server.relativePath}bookmarks/${syncIdTestVal}`)
      .set('content-type', 'application/json')
      .send({ bookmarks: bookmarksDataTestVal });
    expect(response.status).toBe(413);
  });

  it('PUT /bookmarks/:id should return a 401 status code if sync id is invalid', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const response = await request(app)
      .put(`${Config.get().server.relativePath}bookmarks/invalidid`)
      .set('content-type', 'application/json');
    expect(response.status).toBe(401);
  });

  it('PUT /bookmarks/:id should return a 400 status code if bookmarks data not provided', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const response = await request(app)
      .put(`${Config.get().server.relativePath}bookmarks/${syncIdTestVal}`)
      .set('content-type', 'application/json');
    expect(response.status).toBe(400);
  });

  it('PUT /bookmarks/:id should return a 200 status code and last updated date for the provided sync id', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    let response = await request(app)
      .post(`${Config.get().server.relativePath}bookmarks`)
      .set('content-type', 'application/json')
      .send({ version: syncVersionTestVal });
    expect(response.status).toBe(200);
    const id = response.body.id;
    response = await request(app)
      .put(`${Config.get().server.relativePath}bookmarks/${id}`)
      .set('content-type', 'application/json')
      .send({ bookmarks: bookmarksDataTestVal });
    expect(response.status).toBe(200);
    expect(response.type).toBe('application/json');
    expect(Date.parse(response.body.lastUpdated)).not.toBeNaN();
  });

  it('PUT /bookmarks/:id should return a 409 status code when incorrect lastUpdated value provided', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    let response = await request(app)
      .post(`${Config.get().server.relativePath}bookmarks`)
      .set('content-type', 'application/json')
      .send({ version: syncVersionTestVal });
    const id = response.body.id;
    await request(app)
      .put(`${Config.get().server.relativePath}bookmarks/${id}`)
      .set('content-type', 'application/json')
      .send({ bookmarks: bookmarksDataTestVal });
    response = await request(app)
      .put(`${Config.get().server.relativePath}bookmarks/${id}`)
      .set('content-type', 'application/json')
      .send({
        bookmarks: bookmarksDataTestVal,
        lastUpdated: '1970-01-01T00:00:00.000Z',
      });
    expect(response.status).toBe(409);
  });

  it('GET /bookmarks/:id should return a 401 status code if sync id is invalid', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const response = await request(app).get(`${Config.get().server.relativePath}bookmarks/invalidid`);
    expect(response.status).toBe(401);
  });

  it('GET /bookmarks/:id should return a 200 status code and existing bookmarks data for the provided sync id', async () => {
    testConfig.dailyNewSyncsLimit = 0;
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    let response = await request(app)
      .post(`${Config.get().server.relativePath}bookmarks`)
      .set('content-type', 'application/json')
      .send({ version: syncVersionTestVal });
    const id = response.body.id;
    response = await request(app)
      .put(`${Config.get().server.relativePath}bookmarks/${id}`)
      .set('content-type', 'application/json')
      .send({ bookmarks: bookmarksDataTestVal });
    expect(response.status).toBe(200);
    response = await request(app).get(`${Config.get().server.relativePath}bookmarks/${id}`);
    expect(response.status).toBe(200);
    expect(response.type).toBe('application/json');
    expect(response.body.bookmarks).toStrictEqual(bookmarksDataTestVal);
    expect(response.body.version).toStrictEqual(syncVersionTestVal);
    expect(Date.parse(response.body.lastUpdated)).not.toBeNaN();
  });

  it('GET /bookmarks/:id/lastUpdated should return a 401 status code if sync id is invalid', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const response = await request(app).get(`${Config.get().server.relativePath}bookmarks/invalidid/lastUpdated`);
    expect(response.status).toBe(401);
  });

  it('GET /bookmarks/:id/lastUpdated should return a 200 status code and last updated date for the provided sync id', async () => {
    testConfig.dailyNewSyncsLimit = 0;
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    let response = await request(app)
      .post(`${Config.get().server.relativePath}bookmarks`)
      .set('content-type', 'application/json')
      .send({ version: syncVersionTestVal });
    expect(response.status).toBe(200);
    const id = response.body.id;
    response = await request(app).get(`${Config.get().server.relativePath}bookmarks/${id}/lastUpdated`);
    expect(response.status).toBe(200);
    expect(response.type).toBe('application/json');
    expect(Date.parse(response.body.lastUpdated)).not.toBeNaN();
  });

  it('GET /bookmarks/:id/version should return a 401 status code if sync id is invalid', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const response = await request(app).get(`${Config.get().server.relativePath}bookmarks/invalidid/version`);
    expect(response.status).toBe(401);
  });

  it('GET /bookmarks/:id/version should return a 200 status code and last updated date for the provided sync id', async () => {
    testConfig.dailyNewSyncsLimit = 0;
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    let response = await request(app)
      .post(`${Config.get().server.relativePath}bookmarks`)
      .set('content-type', 'application/json')
      .send({ version: syncVersionTestVal });
    expect(response.status).toBe(200);
    const id = response.body.id;
    response = await request(app).get(`${Config.get().server.relativePath}bookmarks/${id}/version`);
    expect(response.status).toBe(200);
    expect(response.type).toBe('application/json');
    expect(response.body.version).toStrictEqual(syncVersionTestVal);
  });
});
</file>

<file path="test/e2e/docs.spec.ts">
import 'jest';
import express from 'express';
import http from 'http';
import https from 'https';
import request from 'supertest';
import * as Config from '../../src/config';
import * as Server from '../../src/server';

describe('Docs', () => {
  let app: express.Express;
  let service: http.Server | https.Server;
  let testConfig: Config.IConfigSettings;

  beforeEach(async () => {
    testConfig = Config.get(true);
    testConfig.log.file.enabled = false;
    testConfig.log.stdout.enabled = false;
    testConfig.db.name = testConfig.tests.db;
    testConfig.server.port = testConfig.tests.port;
    app = await Server.createApplication();
    service = await Server.startService(app);
  });

  afterEach(async () => {
    jest.restoreAllMocks();
    await Server.stopService(service);
  });

  it('GET /: Should return a 200 status code', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const response = await request(app).get(Config.get().server.relativePath);
    expect(response.status).toBe(200);
  });

  it('GET /: Should return HTML content', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const response = await request(app).get(Config.get().server.relativePath);
    expect(response.type).toBe('text/html');
  });
});
</file>

<file path="test/e2e/info.spec.ts">
import 'jest';
import express from 'express';
import http from 'http';
import https from 'https';
import request from 'supertest';
import { ServiceStatus } from '../../src/common/enums';
import * as Config from '../../src/config';
import * as Server from '../../src/server';

describe('InfoRouter', () => {
  let app: express.Express;
  let service: http.Server | https.Server;
  let testConfig: Config.IConfigSettings;

  beforeEach(async () => {
    testConfig = Config.get(true);
    testConfig.log.file.enabled = false;
    testConfig.log.stdout.enabled = false;
    testConfig.db.name = testConfig.tests.db;
    testConfig.server.port = testConfig.tests.port;
    app = await Server.createApplication();
    service = await Server.startService(app);
  });

  afterEach(async () => {
    jest.restoreAllMocks();
    await Server.stopService(service);
  });

  it('GET info: should return api status info', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const response = await request(app).get(`${Config.get().server.relativePath}info`);
    expect(response.status).toBe(200);
    expect(typeof response.body).toBe('object');
    expect(response.body.status).toStrictEqual(ServiceStatus.online);
  });
});
</file>

<file path="test/e2e/server.spec.ts">
import 'jest';
import express from 'express';
import http from 'http';
import https from 'https';
import request from 'supertest';
import * as Config from '../../src/config';
import * as Server from '../../src/server';
import { InfoService } from '../../src/services/info.service';

describe('Server', () => {
  let app: express.Express;
  let service: http.Server | https.Server;
  let testConfig: Config.IConfigSettings;

  beforeEach(async () => {
    testConfig = Config.get(true);
    testConfig.log.file.enabled = false;
    testConfig.log.stdout.enabled = false;
    testConfig.db.name = testConfig.tests.db;
    testConfig.server.port = testConfig.tests.port;
    app = await Server.createApplication();
    service = await Server.startService(app);
  });

  afterEach(async () => {
    jest.restoreAllMocks();
    await Server.stopService(service);
  });

  it('Should return an 500 status code when generic error occurs', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    jest.spyOn(InfoService.prototype, 'getInfo').mockImplementation(() => {
      throw new Error();
    });
    const response = await request(app)
      .get(`${Config.get().server.relativePath}info`)
      .set('content-type', 'application/json');
    expect(response.status).toBe(500);
  });

  it('Should return a 404 status code for an invalid route', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const response = await request(app)
      .get(`${Config.get().server.relativePath}bookmarks`)
      .set('content-type', 'application/json');
    expect(response.status).toBe(404);
  });

  it('Should return a 500 status code when requested api version is not supported', async () => {
    await Server.stopService(service);
    testConfig.allowedOrigins = ['http://test.com'];
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    app = await Server.createApplication();
    service = await Server.startService(app);
    const response = await request(app)
      .get(`${Config.get().server.relativePath}info`)
      .set('content-type', 'application/json');
    expect(response.status).toBe(500);
  });

  it('Should return a 429 status code when request throttling is triggered', async () => {
    await Server.stopService(service);
    testConfig.throttle.maxRequests = 1;
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    app = await Server.createApplication();
    service = await Server.startService(app);
    await request(app).get(`${Config.get().server.relativePath}info`).set('content-type', 'application/json');
    const response = await request(app)
      .get(`${Config.get().server.relativePath}info`)
      .set('content-type', 'application/json');
    expect(response.status).toBe(429);
  });

  it('Should return an 412 status code when requested api version is not supported', async () => {
    jest.spyOn(Config, 'get').mockImplementation(() => {
      return testConfig;
    });
    const response = await request(app)
      .get(`${Config.get().server.relativePath}info`)
      .set('content-type', 'application/json')
      .set('accept-version', '0.0.0');
    expect(response.status).toBe(412);
  });
});
</file>

<file path=".eslintrc.json">
{
  "env": {
    "browser": true,
    "jest": true,
    "node": true
  },
  "extends": [
    "airbnb-typescript/base",
    "plugin:prettier/recommended"
  ],
  "globals": {
    "JSX": "readonly"
  },
  "parserOptions": {
    "ecmaVersion": 2018,
    "project": "./tsconfig.eslint.json",
    "sourceType": "module"
  },
  "plugins": [
    "simple-import-sort",
    "unused-imports"
  ],
  "rules": {
    "@typescript-eslint/comma-dangle": "off",
    "@typescript-eslint/indent": "off",
    "@typescript-eslint/lines-between-class-members": "off",
    "@typescript-eslint/no-unused-vars": "off",
    "@typescript-eslint/no-use-before-define": "off",
    "@typescript-eslint/semi": "warn",
    "class-methods-use-this": "off",
    "consistent-return": "off",
    "func-style": "warn",
    "global-require": "off",
    "import/extensions": "off",
    "import/no-dynamic-require": "off",
    "import/no-extraneous-dependencies": [
      "error",
      {
        "devDependencies": true
      }
    ],
    "import/order": "off",
    "import/prefer-default-export": "off",
    "no-bitwise": "off",
    "no-empty": "off",
    "no-nested-ternary": "off",
    "no-param-reassign": "off",
    "no-undef": "error",
    "no-underscore-dangle": "off",
    "no-unreachable": "warn",
    "no-unused-vars": "warn",
    "prefer-destructuring": "off",
    "prettier/prettier": "warn",
    "simple-import-sort/imports": [
      "warn",
      {
        "groups": [
          [
            "^\\u0000",
            "^@?\\w",
            "^[^.]",
            "^\\."
          ]
        ]
      }
    ],
    "simple-import-sort/exports": "warn",
    "sort-imports": "off",
    "spaced-comment": "off",
    "unused-imports/no-unused-imports-ts": "warn"
  }
}
</file>

<file path=".gitignore">
.dockerignore
*.log
config/settings.json
coverage/
dockerfile
node_modules/
</file>

<file path=".npmrc">
loglevel=silent
</file>

<file path=".prettierrc.json">
{
  "arrowParens": "always",
  "bracketSpacing": true,
  "endOfLine": "lf",
  "overrides": [{
    "files": [
      "*.html"
    ],
    "options": {
      "htmlWhitespaceSensitivity": "ignore",
      "jsxBracketSameLine": true
    }
  }],
  "printWidth": 120,
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5",
  "useTabs": false
}
</file>

<file path=".stylelintrc.json">
{
  "extends": [
    "stylelint-config-standard",
    "stylelint-config-sass-guidelines",
    "stylelint-prettier/recommended"
  ],
  "rules": {
    "declaration-block-no-duplicate-properties": null,
    "declaration-property-value-blacklist": null,
    "font-family-no-missing-generic-family-keyword": null,
    "max-nesting-depth": 20,
    "no-descending-specificity": null,
    "scss/at-extend-no-missing-placeholder": null,
    "scss/selector-no-redundant-nesting-selector": null,
    "selector-max-compound-selectors": null,
    "selector-max-id": null,
    "selector-no-qualifying-type": null,
    "selector-type-no-unknown": null
  }
}
</file>

<file path=".travis.yml">
language: node_js
node_js:
  - 'lts/*'
services:
  - mongodb
install:
  - npm install
script:
  - npm run build
  - npm run coverage
  - npm run test:e2e
</file>

<file path="jest.config.js">
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/*.spec.ts'],
};
</file>

<file path="jestconfig.e2e.json">
{
  "preset": "ts-jest",
  "testEnvironment": "node",
  "testMatch": [
    "<rootDir>/test/e2e/**/*.spec.ts"
  ]
}
</file>

<file path="jestconfig.unit.json">
{
  "preset": "ts-jest",
  "testEnvironment": "node",
  "testMatch": [
    "<rootDir>/src/**/*.spec.ts"
  ]
}
</file>

<file path="LICENSE.md">
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
</file>

<file path="package.json">
{
  "name": "xbrowsersync-api",
  "description": "The REST API service component of the xBrowserSync application.",
  "version": "1.1.13",
  "author": "xBrowserSync",
  "license": "GPL-3.0-only",
  "main": "dist/api.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/xbrowsersync/api.git"
  },
  "bugs": {
    "url": "https://github.com/xbrowsersync/api/issues"
  },
  "scripts": {
    "test": "npm run test:unit && npm run test:e2e",
    "test:unit": "echo Running unit/integration tests... & jest --clearCache && jest --config jestconfig.unit.json --runInBand",
    "test:e2e": "echo Running e2e tests... & jest --clearCache && jest --config jestconfig.e2e.json --runInBand",
    "coverage": "mkdirp coverage && npm run test:unit -- --coverage && coveralls < coverage/lcov.info",
    "lint": "echo Running lint... & eslint src && stylelint src/**/*.scss",
    "clean": "rimraf ./dist",
    "build:docs:dev": "echo Building docs (dev mode)... & webpack --config webpack.config.js --mode development",
    "build:docs": "echo Building docs... & webpack --config webpack.config.js --mode production",
    "build:api:dev": "echo Building api (dev mode)... & npm run clean && tsc --sourceMap && npm run build:docs:dev",
    "build:api": "echo Building api... & npm run clean && tsc && npm run build:docs",
    "build": "npm run lint && npm run build:api",
    "postbuild": "echo Done!",
    "watch:api": "tsc-watch --onSuccess \"node ./dist/api.js\"",
    "watch:docs": "webpack serve --config webpack.config.js --mode development",
    "watch": "npm run build:api:dev && concurrently --kill-others \"npm run watch:api\" \"npm run watch:docs\""
  },
  "engines": {
    "node": ">=8.0.0"
  },
  "dependencies": {
    "bootstrap": "^4.6.0",
    "bunyan": "^1.8.15",
    "core-decorators": "^0.20.0",
    "cors": "^2.8.5",
    "country-list": "^2.2.0",
    "deepmerge": "^4.2.2",
    "dompurify": "^2.2.7",
    "express": "^4.17.1",
    "express-rate-limit": "^5.2.6",
    "express-routes-versioning": "^1.0.1",
    "helmet": "^4.4.1",
    "marked": "^2.0.1",
    "mkdirp": "^1.0.4",
    "moment": "^2.29.1",
    "mongodb": "^3.6.5",
    "mongoose": "^5.12.3",
    "nocache": "^2.1.0",
    "smooth-scroll": "^16.1.3",
    "typeface-roboto-condensed": "^1.1.13",
    "uuid": "^8.3.2",
    "uuid-parse": "^1.1.0"
  },
  "devDependencies": {
    "@types/bunyan": "^1.8.6",
    "@types/cors": "^2.8.10",
    "@types/express": "^4.17.11",
    "@types/express-rate-limit": "^5.1.1",
    "@types/helmet": "^4.0.0",
    "@types/jest": "^26.0.22",
    "@types/marked": "^2.0.1",
    "@types/mongodb": "^3.6.11",
    "@types/mongoose": "^5.10.4",
    "@types/node": "^14.14.37",
    "@types/supertest": "^2.0.11",
    "@types/uuid": "^8.3.0",
    "@types/uuid-parse": "^1.0.0",
    "@typescript-eslint/eslint-plugin": "^4.20.0",
    "@typescript-eslint/parser": "^4.20.0",
    "concurrently": "^6.0.0",
    "coveralls": "^3.1.0",
    "cross-env": "^7.0.3",
    "css-loader": "^5.2.0",
    "eslint": "^7.23.0",
    "eslint-config-airbnb-typescript": "^12.3.1",
    "eslint-config-prettier": "^8.1.0",
    "eslint-plugin-import": "^2.22.1",
    "eslint-plugin-jsx-a11y": "^6.4.1",
    "eslint-plugin-prettier": "^3.3.1",
    "eslint-plugin-simple-import-sort": "^7.0.0",
    "eslint-plugin-unused-imports": "^1.1.1",
    "file-loader": "^6.2.0",
    "html-loader": "^2.1.2",
    "html-webpack-plugin": "^5.3.1",
    "jest": "^26.6.3",
    "mini-css-extract-plugin": "^1.4.0",
    "node-sass": "^5.0.0",
    "postcss-loader": "^5.2.0",
    "prettier": "^2.2.1",
    "rimraf": "^3.0.2",
    "sass-loader": "^11.0.1",
    "stylelint": "^13.12.0",
    "stylelint-config-prettier": "^8.0.2",
    "stylelint-config-sass-guidelines": "^8.0.0",
    "stylelint-config-standard": "^21.0.0",
    "stylelint-prettier": "^1.2.0",
    "supertest": "^6.1.3",
    "ts-jest": "^26.5.4",
    "ts-loader": "^8.1.0",
    "ts-node": "^9.1.1",
    "tsc-watch": "^4.2.9",
    "typescript": "^4.2.3",
    "webpack": "^5.28.0",
    "webpack-cli": "^4.6.0",
    "webpack-dev-server": "^3.11.2"
  }
}
</file>

<file path="README.md">
# xBrowserSync
## API service

[![Build Status](https://travis-ci.org/xbrowsersync/api.svg)](https://travis-ci.org/xbrowsersync/api) [![Coverage Status](https://coveralls.io/repos/github/xbrowsersync/api/badge.svg?branch=master)](https://coveralls.io/github/xbrowsersync/api?branch=master) ![Dependencies](https://img.shields.io/depfu/xbrowsersync/api) [![Known Vulnerabilities](https://snyk.io/test/github/xbrowsersync/api/badge.svg?targetFile=package.json)](https://snyk.io/test/github/xbrowsersync/api?targetFile=package.json) [![GitHub license](https://img.shields.io/github/license/xbrowsersync/api.svg)](https://github.com/xbrowsersync/api/blob/master/LICENSE.md) [![Liberapay patrons](http://img.shields.io/liberapay/patrons/xbrowsersync.svg?logo=liberapay)](https://liberapay.com/xbrowsersync/donate)

[![GitHub stars](https://img.shields.io/github/stars/xbrowsersync/api.svg?style=social&label=Star)](https://github.com/xbrowsersync/api)
[![GitHub forks](https://img.shields.io/github/forks/xbrowsersync/api.svg?style=social&label=Fork)](https://github.com/xbrowsersync/api/fork)

xBrowserSync is a free tool for syncing browser data between different browsers and devices, built for privacy and anonymity. For full details, see [www.xbrowsersync.org](https://www.xbrowsersync.org/).

This repository contains the source code for the REST service API that client applications communicate with. If you'd like to run your own xBrowserSync service on your [Node.js](https://nodejs.org/) web server, follow the installation steps below.

Once configured, you can begin syncing your browser data to your xBrowserSync service, and if you're feeling generous, [allow others to sync their data to your service](https://www.xbrowsersync.org/#getinvolved) also!

## API documentation

The available API methods are documented on the home page of each xBrowserSync service, respective of the version that service is running. For example, you can view the API documentation for the official xBrowserSync service at [api.xbrowsersync.org](https://api.xbrowsersync.org/).

## Running with Docker

The easiest way to get up and running is by using [Docker](https://www.docker.com/) to run the xBrowserSync API as a container. Docker is a popular container management and imaging platform that allows you to quickly work with containers on Linux and Windows.

Once you have installed Docker you can use the [xBrowserSync API Docker image](https://hub.docker.com/r/xbrowsersync/api) to get a production-ready xBrowserSync service up and running with minimal effort (view the [README](https://github.com/xbrowsersync/api-docker/blob/master/README.md) for more information).

## Manual installation

Whilst running in a Docker container is the recommended way to run your xBrowserSync service, you can self-host xBrowserSync instead by performing a manual installation on your own server by installing the two dependencies listed as prerequisites and following the six easy steps below:

### Prerequisites

- [Node.js](https://nodejs.org/)
- [MongoDB](https://www.mongodb.com/)

### 1. Clone the xBrowserSync API source repo

    $ git clone https://github.com/xbrowsersync/api.git

### 2. Install and build xBrowserSync API package

  (Use the `unsafe-perm` flag if you get any permissions issues whilst trying to install):

    $ npm install --unsafe-perm

### 3. Configure MongoDB databases

  1. Run the following commands in the mongo shell:
  
      (Replace `[password]` with a cleartext password of your choice)

      ```
      use admin
      db.createUser({ user: "xbrowsersyncdb", pwd: "[password]", roles: [ { role: "readWrite", db: "xbrowsersync" }, { role: "readWrite", db: "xbrowsersynctest" } ] })
      use xbrowsersync
      db.newsynclogs.createIndex( { "expiresAt": 1 }, { expireAfterSeconds: 0 } )
      db.newsynclogs.createIndex({ "ipAddress": 1 })
      ```

  2. Add the following environment variables to hold xBrowserSync DB account username and password:

      - `XBROWSERSYNC_DB_USER`
      - `XBROWSERSYNC_DB_PWD`

      On Windows, open a Command Prompt and type (replacing `[password]` with the password entered in the mongo shell):
  
      ```
      setx XBROWSERSYNC_DB_USER "xbrowsersyncdb"
      setx XBROWSERSYNC_DB_PWD "[password]"
      ```
  
      On Ubuntu/Debian Linux, open a terminal emulator and type:
      
      ```
      $ pico ~/.profile
      ```
      
      Add the lines (replacing `[password]` with the password entered in the mongo shell):
      
      ```
      export XBROWSERSYNC_DB_USER=xbrowsersyncdb
      export XBROWSERSYNC_DB_PWD=[password]
      ```
      
      Save and exit, then log out and back in again.

  #### If exposing your service to the public it is recommended you also perform the following steps:
  
  3. Add a TTL index on `bookmarks.lastAccessed` to delete syncs that have not been accessed for 3 weeks:
   
      ```
      use xbrowsersync
      db.bookmarks.createIndex( { "lastAccessed": 1 }, { expireAfterSeconds: 21*86400 } )
      ```

### 4. Modify configuration settings

The file `config/settings.default.json` contains all of the default configuration settings. User configuration values should be stored in `config/settings.json` and will override the defaults. Should you wish to change any of the configuration settings, copy `settings.default.json` and rename the copy to `settings.json` before changing any values as required. Be sure to remove any settings that have not been changed so that any amendments to the default values in future versions are picked up. For example, a basic user configuration to modify the service status message could look like:

```
{
  "status": {
    "message": "Welcome to my xBrowserSync service!"
  }
}
```

Any changes to the user configuration will require the service to be restarted before being picked up. The available configuration settings are:

Config Setting | Description | Default Value
-------------- | ----------- | -------------
`allowedOrigins` | Array of origins permitted to access the service. Each origin can be a `String` or a `RegExp`. For example `[ 'http://example1.com', /\.example2\.com$/ ]` will accept any request from `http://example1.com` or from a subdomain of `example2.com`. If the array is empty, all origins are permitted | `[]` (All origins permitted)
`dailyNewSyncsLimit` | The maximum number of new syncs that a user can create per day - helps to prevent abuse of the service. If this setting is enabled, IP addresses are added to newsynclogs collection to track usage which is cleared down each day. Set as `0` to disable (allows users to create as many syncs as they want). | `3`
`db.authSource` | The database to use for authentication. | `admin`
`db.connTimeout` | The connection timeout period to use for MongoDB. Using a high value helps prevent dropped connections in a hosted environment. | `30000` (30 secs)
`db.host` | The MongoDB server address to connect to, either a hostname, IP address, or UNIX domain socket. | `127.0.0.1`
`db.name` | Name of the MongoDB database to use. | `xbrowsersync`
`db.ssl` | Connect to MongoDB over SSL. | `false`
`db.useSRV` | Use MongoDB's [DNS Seedlist Connection Format](https://docs.mongodb.com/manual/reference/connection-string/#dns-seedlist-connection-format) to connect to the database. If set to true, `db.host` should also be set to the relevant DNS hostname. | `false`
`db.username` | Username of the account used to access MongoDB. Set as empty string to use environment variable `XBROWSERSYNC_DB_USER`. | (Empty string, defers to environment variable)
`db.password` | Password of the account used to access MongoDB. Set as empty string to use environment variable `XBROWSERSYNC_DB_PWD`. | (Empty string, defers to environment variable)
`db.port` | The port to use to connect to MongoDB. | `27017`
`location` | The geographic location of the service, determined by an ISO 3166-1-alpha-2 code. Helps users determine if the service is geographically suitable for them when exposing the service to the public. | `gb`
`log.file.enabled` | If set to true, [Bunyan](https://github.com/trentm/node-bunyan) will be used to capture minimal logging (service start/stop, new sync created, errors) to file. Logged messages are output to `log.file.path` and the log file is rotated automatically each period set by `log.file.rotationPeriod`, resulting in files "`log.file.path`.0", "`log.file.path`.1", etc. | `true`
`log.file.level` | Bunyan log level to capture: `trace`, `debug`, `info`, `warn`, `error`, `fatal`. | `info`
`log.file.path` | File path to log messages to (ensure the account node is running as has permission to write to this location). | `/var/log/xBrowserSync/api.log`
`log.file.rotatedFilesToKeep` | Maximum number of rotated log files to retain. | `5`
`log.file.rotationPeriod` | 	The period at which to rotate log files. This is a string of the format "$number$scope" where "$scope" is one of "ms" (milliseconds -- only useful for testing), "h" (hours), "d" (days), "w" (weeks), "m" (months), "y" (years). Or one of the following names can be used "hourly" (means 1h), "daily" (1d), "weekly" (1w), "monthly" (1m), "yearly" (1y). Rotation is done at the start of the scope: top of the hour (h), midnight (d), start of Sunday (w), start of the 1st of the month (m), start of Jan 1st (y). | `1d`
`log.stdout.enabled` | If set to true, [Bunyan](https://github.com/trentm/node-bunyan) will be used to capture minimal logging (service start/stop, new sync created, errors) to stdout. | `true`
`log.stdout.level` | Bunyan log level to capture: `trace`, `debug`, `info`, `warn`, `error`, `fatal`. | `info`
`maxSyncs` | The maximum number of unique syncs to be stored on the service, once this limit is reached no more new syncs are permitted. Users with an existing sync ID are able to get and update their sync data as normal. This value multiplied by the maxSyncSize will determine the maximum amount of disk space used by the xBrowserSync service. Set as `0` to disable. | `5242`
`maxSyncSize` | The maximum sync size in bytes. Note this is not equivalent to the size/amount of bookmarks as data is compressed and encrypted client-side before being sent to the service. | `512000` (500kb)
`server.behindProxy` | Set to `true` if service is behind a proxy, client IP address will be set from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For) header. Important: Do not set to `true` unless a proxy is present otherwise client IP address can easily be spoofed by malicious users. | `false`
`server.host` | Host name or IP address to use for Node.js server for accepting incoming connections. | `127.0.0.1`
`server.https.certPath` | Path to a valid SSL certificate. Required when HTTPS is enabled. | (Empty string, no path set)
`server.https.enabled` | If enabled, the service is started using HTTPS. | `false`
`server.https.keyPath` | Path to the SSL certificate's private key. Required when HTTPS is enabled. | (Empty string, no path set)
`server.port` | Port to use for Node.js server for accepting incoming connections. | `8080`
`server.relativePath` | Relative path from the host where the service will be located. Should always begin (and end) with `/`. | `/`
`status.allowNewSyncs` | Determines whether users will be allowed to create new syncs. Note: if this setting is set to false, users who have already synced to this service and have a sync ID will still able to get and update their syncs. | `true`
`status.message` | This message will be displayed in the service status panel of the client app when using this xBrowserSync service. Ideally the message should be 130 characters or less. Supports [markdown](https://guides.github.com/features/mastering-markdown/) formatting. | (Empty string, no message set)
`status.online` | If set to false no clients will be able to connect to this service. | `true`
`tests.db` | Name of the MongoDB database to use for e2e tests. | `xbrowsersynctest`
`tests.port` | Port to use for running tests. | `8081`
`throttle.maxRequests` | Max number of connections during `throttle.timeWindow` milliseconds before sending a 429 response. Set as `0` to disable. | `1000`
`throttle.timeWindow` | Amount of time (in milliseconds) before throttle counter is reset. | `300000` (5 mins)

### 5. Create log folder

Ensure that the path set in the `log.path` config value exists, and that the account node will be running as can write to that location.

### 6. Run xBrowserSync service

    $ node dist/api.js

## Building

If you've made code changes you can run a fresh build with the command:

    $ npm run build

## Testing

The project includes unit, integration and end to end tests.

To run end to end tests, you will need to create the test database first. Run the following commands in the mongo shell:

  (Replace `[dbname]` with your xBrowserSync database name and `[password]` with the xBrowserSync database user account password)

  ```
  use [dbname]test
  db.createUser({ user: "xbrowsersyncdb", pwd: "[password]", roles: ["readWrite"] })
  ```

You can then run the end to end tests by running the following command:

    $ npm run test

## Upgrading from an earlier version

### <= v1.1.5

From v1.1.6, database users are created in the admin database. When upgrading from an earlier version you'll either need to drop the existing users in the xbrowsersync database and recreate them in the admin database, or simply add the following to your `config/settings.json` file:

  ```
  "db": {
    "authSource": "xbrowsersync"
  }
  ```

Config settings for logging has also changed so ensure you update your `config/settings.json` file if you have customised logging settings.

### <= v1.0.3

If you are curently running v1.0.3 (or earlier) of the xBrowserSync API, you will need to export existing syncs and delete the xBrowserSync database before upgrading.

To export existing syncs, run the following command:

  ```
  mongoexport --db xBrowserSync -c bookmarks --out /path/to/export/file
  ```

Then to delete the database, run the following commands in the mongo shell:

  ```
  use xBrowserSync
  db.dropAllUsers()
  db.dropDatabase()
  ```

Once you've upgraded and completed the installation steps below, you can import the syncs by running the following command:

  ```
  mongoimport --db xbrowsersync -c bookmarks --file /path/to/export/file
  ```

## Other Implementations

### Google Cloud

- [sbogomolov/xbrowsersync-gcf](https://github.com/sbogomolov/xbrowsersync-gcf): An implementation of the xBrowserSync API using Google Cloud Functions with Firestore backend.

### Cloudflare Worker

- [txchen/xbrowsersync-cfw](https://github.com/txchen/xbrowsersync-cfw): An implementation of the xBrowserSync API using Cloudflare worker and KV.

## VS Code

If you're using [VS Code](https://code.visualstudio.com/), you have the following launch configurations:

  1. Debug API: Will compile and debug the main API service.
  2. Debug docs: Will launch API home page in chrome and attach to debugger for debugging docs issues. 
  3. Run unit/integration tests: Will debug tests in `*.spec.ts` files in `src` folder.
  4. Run e2e tests: Will debug tests in `test/e2e` folder.

Note: we recommend [VSCodium](https://github.com/VSCodium/vscodium/) for running VSCode without Microsoft's proprietary binaries and telemetry/tracking. 

## Issues and feature requests

Please log Docker-related issues in the [api-docker Issues list](https://github.com/xbrowsersync/api-docker/issues), if you have found an issue with the xBrowserSync API itself or wish to request a new feature, do so in the [api Issues list](https://github.com/xbrowsersync/api/issues/).
</file>

<file path="tsconfig.eslint.json">
{
  "extends": "./tsconfig.json",
  "include": ["*.js", "src", "test"],
  "exclude": [],
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "module": "commonjs",
    "outDir": "dist",
    "resolveJsonModule": true,
    "rootDir": "src",
    "skipLibCheck": true,
    "sourceMap": false,
    "target": "es2017"
  },
  "include": ["src"],
  "exclude": ["src/**/*.spec.ts", "src/docs"],
}
</file>

<file path="webpack.config.js">
const HtmlWebPackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const Path = require('path');

module.exports = {
  entry: ['./src/docs/index.ts', './src/docs/styles.scss'],
  output: {
    filename: 'index.js',
    path: Path.resolve(__dirname, 'dist/docs'),
  },
  devtool: 'source-map',
  devServer: {
    contentBase: Path.join(__dirname, 'dist'),
    compress: true,
    port: 8083,
  },
  module: {
    rules: [
      {
        test: /\.html$/,
        use: [
          {
            loader: 'html-loader',
            options: { minimize: true },
          },
        ],
      },
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.(sa|sc|c)ss$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'],
      },
      {
        test: /\.(svg|jpg|gif|woff|woff2|eot|ttf|otf)$/,
        use: 'file-loader',
      },
    ],
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],
  },
  plugins: [
    new HtmlWebPackPlugin({
      template: 'src/docs/index.html',
      filename: 'index.html',
    }),
    new MiniCssExtractPlugin({
      filename: 'styles.css',
    }),
  ],
  stats: 'errors-only',
};
</file>

</files>
